\documentclass[11pt,a4paper]{article}
\usepackage{isabelle,isabellesym}

% further packages required for unusual symbols (see also
% isabellesym.sty), use only when needed

%\usepackage{amssymb}
  %for \<leadsto>, \<box>, \<diamond>, \<sqsupset>, \<mho>, \<Join>,
  %\<lhd>, \<lesssim>, \<greatersim>, \<lessapprox>, \<greaterapprox>,
  %\<triangleq>, \<yen>, \<lozenge>

%\usepackage{eurosym}
  %for \<euro>

%\usepackage[only,bigsqcap]{stmaryrd}
  %for \<Sqinter>

%\usepackage{eufrak}
  %for \<AA> ... \<ZZ>, \<aa> ... \<zz> (also included in amssymb)

%\usepackage{textcomp}
  %for \<onequarter>, \<onehalf>, \<threequarters>, \<degree>, \<cent>,
  %\<currency>

% this should be the last package used
\usepackage{pdfsetup}

% urls in roman style, theory text in math-similar italics
\urlstyle{rm}
\isabellestyle{it}

% for uniform font size
%\renewcommand{\isastyle}{\isastyleminor}


\begin{document}

\title{Formal Verification of Deed contract\\in Ethereum Name Service}
\author{Yoichi Hirai\footnote{\texttt{i@yoichihirai.com}}}
\maketitle

\tableofcontents

% sane default for proof documents
\parindent 0pt\parskip 0.5ex

\section{Introduction}

This document describes a formal verification result about one contract in
an Ethereum Name Service implementation.
This document was generated by the Isabelle proof assistant\footnote{However, that is not the guarantee of truth.  Check the notion of ``Pollack inconsistency''.}.
Isabelle/HOL checked all lemmata to be correct (but definitions are not,
especially there is no reason yet to believe the new EVM implementation is accurate).

The verified contract is relatively small,
but this is the first ``real''\footnote{The word ``real'' means it's
produced by the Solidity compiler and aimed for production.}
contract that I have analyzed.

The verification is result far from perfect.
I'm still finding more problems in the
formalization than in the contracts.  The EVM implementation is not tested against
others!

I'm making this public already because this project makes a
good example on the amount of work (and the level of detail) required to
verify a smart contract using machine-assisted logical inference.  At this
point already, if I were to
implement a smart contract that holds more than 100k dollars, and if
I'm in charge of controlling the schedule, I would consider this kind of
development (the other option is to try the contract with smaller values first).

\subsection{Which Smart Contract this Document is about}

The target of the verification is the \texttt{Deed} contract%
\footnote{\url{https://github.com/Arachnid/ens/blob/f3334337083728728da56824a5d0a30a8712b60c/HashRegistrarSimplified.sol\#L25}},
which is a part of the Ethereum Name Service.
The current development uses the bytecode obtained from the
Solidity compiler version \url{https://github.com/ethereum/solidity/tree/2d9109ba453d49547778c39a506b0ed492305c16}.

Most parts of this document are generic to all Ethereum smart
contracts.  Only the last section is specific to the Deed contract.

\subsection{What is Proven}

The proven property is about one invocation of the Deed contract.
In short, ``only the registrar can decrease the balance.''
The invocation can be deep into the nested reentrancy calls, but pick
one of these.
There are assumptions and there are conclusions.

Assumptions at the invocations:
\begin{itemize}
  \item the account has the bytecode of the Deed contract or the
    account has no code;
  \item the caller does not have the address stored at index~0 of the
    account's storage (i.e. is not the registrar);
  \item the 21st least byte in storage index~2 is not zero\footnote{I didn't know this condition until Isabelle/HOL complained.  This shows the possibillity of using theorem provers to find vulnerabilities.};
  \item the account's balance and the sent value added together do not
    overflow the range of 256-bit unsigned integers;
  \item the account is not marked as killed.
\end{itemize}

Conclusions when the invocation finishes:
\begin{itemize}
  \item the account's balance after the call is not smaller than the
    account's balance before the call;
  \item the account is not marked as killed after the call; and
  \item the 21st least byte in storage index~2 is still not zero;
  \item the account's registrar is not changed.
\end{itemize}


\subsection{What can Go Wrong}

The analysis cuts corners but it is reasonablly equipped for safety
properties (i.e. ``certain changes never happen on the account
state'').  The analysis considers reentrancy, the account erasure after execution
of the \texttt{SUICIDE} opcode, the byte level organization of EVM
memory and storage, and the fact that the balance of an account can
increase even when the code of the account is not invoked.
The analysis is not aware of out-of-gas failures and the stack depth
failures, but the analysis does not miss any kind of account state
changes because of that.

The biggest pitfall currently is the untested EVM implementation.
Although this is a new EVM implmentation, it is not
tested against the standard EVM tests!  This is already wrong.
So, after getting this document in shape, the next thing I try is to
test the new EVM implementation against the standard EVM tests.

I wrote yet another EVM implementation because it allows us to reason about all possible executions!

\subsection{Verifying Other Contracts}

Most parts of the development can be reused for verifying other contracts.
The amount of work is
different for every smart contract.  It would be relatively
straighforward to do something similar for
contracts without loops.  For contracts with loops,
either lots of manual work or some more
sophisticated machinary is necessary.

This development so far does not use sophisticated techniques.
An appropriate description would be ``a brute-force approach based on a bare machine model''.
Apart from the tool Isabelle/HOL itself, I used no techniques from the 21st century yet.

\subsection{Links}

\begin{itemize}
\item This document is produced from the code available at
\url{https://github.com/pirapira/eth-isabelle}.
\item To get updates on similar projects, follow \url{http://gitter.im/ethereum/formal-methods}.
\end{itemize}

% generated text of all theories
\input{session}

% optional bibliography
%\bibliographystyle{abbrv}
%\bibliography{root}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
