\documentclass[11pt,a4paper]{article}
\usepackage{isabelle,isabellesym}

% further packages required for unusual symbols (see also
% isabellesym.sty), use only when needed

%\usepackage{amssymb}
  %for \<leadsto>, \<box>, \<diamond>, \<sqsupset>, \<mho>, \<Join>,
  %\<lhd>, \<lesssim>, \<greatersim>, \<lessapprox>, \<greaterapprox>,
  %\<triangleq>, \<yen>, \<lozenge>

%\usepackage{eurosym}
  %for \<euro>

%\usepackage[only,bigsqcap]{stmaryrd}
  %for \<Sqinter>

%\usepackage{eufrak}
  %for \<AA> ... \<ZZ>, \<aa> ... \<zz> (also included in amssymb)

%\usepackage{textcomp}
  %for \<onequarter>, \<onehalf>, \<threequarters>, \<degree>, \<cent>,
  %\<currency>

% this should be the last package used
\usepackage{pdfsetup}

% urls in roman style, theory text in math-similar italics
\urlstyle{rm}
\isabellestyle{it}

% for uniform font size
%\renewcommand{\isastyle}{\isastyleminor}


\begin{document}

\title{Formal Verification of Deed Contract\\in Ethereum Name Service}
\author{Yoichi Hirai\footnote{\texttt{i@yoichihirai.com}}}
\maketitle

\tableofcontents

% sane default for proof documents
\parindent 0pt\parskip 0.5ex

\newpage

\section{Introduction}

\subsection{What this Document is}
This document describes a formal verification result about one contract in
an Ethereum Name Service implementation.
This document was generated by the Isabelle proof assistant\footnote{However, that is not the guarantee of truth.  Check the notion of ``Pollack inconsistency''.}.
Isabelle/HOL checked all lemmata to be correct (though it cannot check the definitions against reality).

The verified contract is relatively small,
but this is the first ``real''\footnote{The word ``real'' means it is aimed for production.}
contract that I have analyzed in a theorem proving environment.

The verification is result far from perfect.
I am still finding more problems in the verification setup than in the verified contracts.
The EVM (Ethereum Virtual Machine) implementation is not tested against others!

I am making this public already because this project makes a
good example on the amount of work (and the level of detail) required to
verify a smart contract using the machine-assisted logical inference.  At this
point already, if I were to
implement a smart contract that holds more than 100k dollars, and if
I am in charge of the schedule, I would consider this kind of
development (the other option is to try the contract with smaller values first).

\paragraph{Acknowledgment.}
Most of the work has been carried out during my working hours in Ethereum DEV UG.
I would like to thank Sami M\"akel\"a for suggestions and corrections of my mistakes.

\subsection{Which Smart Contract this Document is about}

The target of the verification is the \texttt{Deed} contract%
\footnote{\url{https://github.com/Arachnid/ens/blob/f3334337083728728da56824a5d0a30a8712b60c/HashRegistrarSimplified.sol\#L25}},
which is a part of the Ethereum Name Service.
The current development uses the bytecode obtained from the
Solidity compiler version \url{https://github.com/ethereum/solidity/tree/2d9109ba453d49547778c39a506b0ed492305c16}.

Most parts of this document are generic to all Ethereum smart
contracts.  Only the last section is specific to the Deed contract.

\subsection{What is Proven}

The proven property is about one invocation of the Deed contract.
In short, ``only the registrar can decrease the balance.''
The invocation can be deep into the nested reentrancy calls, but the property holds for any one of these.
I can list the assumptions and the implied conclusions.

Assumptions at the invocation:
\begin{itemize}
  \item the account has the bytecode of the Deed contract or the
    account has no code;
  \item the caller's address it not the one stored at index~0 of the
    account's storage (i.e. the caller is not the \texttt{registrar})\footnote{I'm guessing that the storage index~0 contains the registrar's address.  To do this properly I need the help of the Solidity compiler.};
  \item the 21st least byte in storage index~2 is not zero (i.e. the contract is still \texttt{active})\footnote{I didn't know this condition until Isabelle/HOL complained.  This shows the possibility of using theorem provers to find vulnerabilities.};
  \item the account's balance and the sent value added together do not
    overflow the range of 256-bit unsigned integers;
  \item the account is not marked as killed.
\end{itemize}

Conclusions when the invocation finishes (i.e. when the contract returns or fails back to the same depth in the callstack):
\begin{itemize}
  \item the account's balance after the call is not smaller than the
    account's balance before the call;
  \item the account is not marked as killed after the call; and
  \item the 21st least byte in storage index~2 is still not zero (the account is still \texttt{active});
  \item the storage content at index 0 (the \texttt{registrar}) is not changed.
\end{itemize}


\subsection{What can Go Wrong}

The property above is only a safety property; it states something bad is not going to happen.  This does not mean anything good happens.  While it is feasible to prove that something good happens, at least I need to model the gas mechanism in Isabelle/HOL before I claim anything works.  In any case, when you have a sequence of events in mind, you can test that.  Theorem proving excels at uncovering unknown possibilities.

The analysis cuts corners but it is reasonably equipped for safety
properties.  The analysis considers reentrancy, the account erasure after execution
of the \texttt{SUICIDE} opcode, the byte level organization of EVM
memory and storage, and the fact that the balance of an account can
increase even when the code of the account is not invoked.
The analysis is not aware of out-of-gas failures and the stack depth
failures, but the analysis does not miss any kind of account state
changes because of that.  The verification is given up at the moment
DELEGATE or CALLCODE instruction is used.

The hex output from Solidity is parsed by a new parser, which might produce incorrect results.

The biggest pitfall currently is the untested EVM implementation.
Although this is a new EVM implementation, it is not
tested against the standard EVM tests!  This is already wrong.
So, after getting this document in shape, the next thing I try is to
test the new EVM implementation against the standard EVM tests (but before this I need to implement the gas).
There is one good thing about the new EVM implementation. It allows us to reason about all possible executions!

\subsection{Verifying Other Contracts}

Most parts of the development can be reused for verifying other contracts.
The amount of work is
different for every smart contract.  It would be relatively
straightforward to do something similar for
contracts without loops.  For contracts with loops,
either lots of manual work or some more
sophisticated machinery is necessary.

This development so far does not use sophisticated techniques.
An appropriate description would be ``a brute-force approach based on a bare machine model.''
Apart from the tool Isabelle/HOL itself, I used no verification techniques from the 21st century yet.

\subsection{Links}

\begin{itemize}
\item This document is produced from the code available at
\url{https://github.com/pirapira/eth-isabelle/tree/deed}.
\item To get updates on this project and similar ones, follow \url{http://gitter.im/ethereum/formal-methods}.
\end{itemize}

% generated text of all theories
\input{session}

% optional bibliography
%\bibliographystyle{abbrv}
%\bibliography{root}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
