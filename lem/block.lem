(**)
(*Copyright 2016 Sami Mäkelä*)
(**)
(* Licensed under the Apache License, Version 2.0 (the "License"); *)
(* you may not use this file except in compliance with the License. *)
(* You may obtain a copy of the License at *)
(**)
(*       http://www.apache.org/licenses/LICENSE-2.0 *)
(**)
(* Unless required by applicable law or agreed to in writing, software *)
(* distributed under the License is distributed on an "AS IS" BASIS, *)
(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)
(* See the License for the specific language governing permissions and *)
(* limitations under the License. *)

open import Pervasives
(*
open import Word
open import Word160
*)
open import Word8
open import Word256
open import Keccak
open import Evm

type transaction = <|
  tr_from : address;
  tr_to : maybe address;
  tr_gas_limit : w256;
  tr_gas_price : w256;
  tr_value : w256;
  tr_nonce : w256;
  tr_data : list byte;
|>

type account = <|
  account_address : address;
  account_storage : storage;
  account_code : program;
  account_balance : w256;
  account_nonce : w256;
  account_killed : bool;
    (* the boolean that indicates the account has executed SUICIDE in this transaction. *)
  (* The flag causes a destruction of the contract at the end of a transaction. *)
|>


val build_cctx : account -> constant_ctx
let build_cctx a =
  <| cctx_program = a.account_code; cctx_this = a.account_address; cctx_hash_filter = (fun _ -> true) |>

(* Next we turn to the case where the environment returns back to the account after the account has *)
(* called an account.  In this case, the account should contain one ongoing execution that is waiting *)
(* for a call to return. *)

(* Second I define the empty account, which replaces an account that has *)
(* destroyed itself. *)

val empty_account : address -> account
let empty_account addr =
 <| account_address = addr;
    account_storage = empty_storage;
   account_code = empty_program;
   account_balance = 0;
   account_killed = false;
   account_nonce = 0;
 |>

(* And after our contract makes a move, the account state is updated as follows. *)

type world_state = address -> account

type receipt = <|
  receipt_state : world_state;
  receipt_cumulative_gas : w256;
  receipt_bloom : w256;
  receipt_logs : list log_entry;
|>

type block = <|
  block_parent_hash : w256;
  block_uncles_hash : list w256;
  block_coinbase : address;
  block_state : world_state;
  block_transactions : list (transaction * receipt);
  block_logs_bloom : w256;
  block_difficulty : w256;
  block_number : w256;
  block_gas_limit : w256;
  block_timestampt : w256;
  block_nonce : w256;
|>

let start_env a state args caller origin block =
<| vctx_stack = []; (* The stack is initialized for every invocation *)
    vctx_memory = empty_memory; (* The memory is also initialized for every invocation *)
     vctx_memory_usage = 0; (* The memory usage is initialized. *)
     vctx_storage = a.account_storage; (* The storage is taken from the account state *)
     vctx_pc = 0; (* The program counter is initialized to zero *)
     vctx_balance = (fun (addr:address) -> (state addr).account_balance);
     vctx_caller = caller; (* the caller is specified by the environment *)
     vctx_value_sent = args.callarg_value; (* the sent value is specified by the environment *)
     vctx_data_sent = args.callarg_data; (* the sent data is specified by the environment *)
     vctx_storage_at_call = a.account_storage; (* the snapshot of the storage is remembered in case of failure *)
     vctx_balance_at_call = (fun (addr:address) -> (state addr).account_balance); (* the snapshot of the balance is remembered in case of failure *)
     vctx_origin = origin; (* the origin of the transaction is arbitrarily chosen *)
     vctx_ext_program = (fun (addr:address) -> (state addr).account_code); (* the codes of the external programs are arbitrary. *)
     vctx_block = block; (* the block information is chosen arbitrarily. *)
     vctx_gas = word256ToInteger args.callarg_gas; (* the amount of gas is chosen arbitrarily. *)
     vctx_account_existence = (fun _ -> true); (* existence is chosen arbitrarily *)
     vctx_touched_storage_index = [];
     vctx_logs = []
   |>

let create_env a state value data gas caller origin block =
<| vctx_stack = []; (* The stack is initialized for every invocation *)
    vctx_memory = empty_memory; (* The memory is also initialized for every invocation *)
     vctx_memory_usage = 0; (* The memory usage is initialized. *)
     vctx_storage = a.account_storage; (* The storage is taken from the account state *)
     vctx_pc = 0; (* The program counter is initialized to zero *)
     vctx_balance = (fun (addr:address) -> (state addr).account_balance);
     vctx_caller = caller; (* the caller is specified by the environment *)
     vctx_value_sent = value; (* the sent value is specified by the environment *)
     vctx_data_sent = data; (* the sent data is specified by the environment *)
     vctx_storage_at_call = a.account_storage; (* the snapshot of the storage is remembered in case of failure *)
     vctx_balance_at_call = (fun (addr:address) -> (state addr).account_balance); (* the snapshot of the balance is remembered in case of failure *)
     vctx_origin = origin; (* the origin of the transaction is arbitrarily chosen *)
     vctx_ext_program = (fun (addr:address) -> (state addr).account_code); (* the codes of the external programs are arbitrary. *)
     vctx_block = block; (* the block information is chosen arbitrarily. *)
     vctx_gas = word256ToInteger gas; (* the amount of gas is chosen arbitrarily. *)
     vctx_account_existence = (fun _ -> true); (* existence is chosen arbitrarily *)
     vctx_touched_storage_index = [];
     vctx_logs = []
   |>

let vctx_update_from_world v a state called_v = <| v with
     vctx_storage = a.account_storage; (* The storage is taken from the account state *)
     vctx_balance = (fun (addr:address) -> (state addr).account_balance);
     vctx_balance_at_call = (fun (addr:address) -> (state addr).account_balance); (* the snapshot of the balance is remembered in case of failure *)
     vctx_ext_program = (fun (addr:address) -> (state addr).account_code); (* the codes of the external programs are arbitrary. *)
     vctx_gas = v.vctx_gas + called_v.vctx_gas;
     vctx_logs = v.vctx_logs ++ called_v.vctx_logs;
|>

val byte_to_inst : byte -> inst
let byte_to_inst b =
 if b = 0X00 then Misc STOP else
 if b = 0X16 then Bits inst_AND else
 if b = 0X17 then Bits inst_OR else
 if b = 0X18 then Bits inst_XOR else
 if b = 0X19 then Bits inst_NOT else
 if b = 0X1a then Bits BYTE else
 if b = 0Xf0 then Misc CREATE else
 if b = 0Xf1 then Misc CALL else
 if b = 0Xf2 then Misc CALLCODE else
 if b = 0Xf3 then Misc RETURN else
 if b = 0Xf4 then Misc DELEGATECALL else
 if b = 0Xff then Misc SUICIDE else
 if b = 0Xa0 then Log LOG0 else
 if b = 0Xa1 then Log LOG1 else
 if b = 0Xa2 then Log LOG2 else
 if b = 0Xa3 then Log LOG3 else
 if b = 0Xa4 then Log LOG4 else
 if b = 0X35 then Stack CALLDATALOAD else
 if b = 0X50 then Stack POP else
 if b > 0X5f && b <= 0X5f+32 then Stack (PUSH_N (replicate (natFromInt (word8ToInt (b-0X5f))) 0)) else
 if b = 0X56 then Pc JUMP else
 if b = 0X57 then Pc JUMPI else
 if b = 0X58 then Pc PC else
 if b = 0X5b then Pc JUMPDEST else
 if b = 0X54 then Storage SLOAD else
 if b = 0X55 then Storage SSTORE else
 if b = 0X51 then Memory MLOAD else
 if b = 0X52 then Memory MSTORE else
 if b = 0X53 then Memory MSTORE8 else
 if b = 0X37 then Memory CALLDATACOPY else
 if b = 0X39 then Memory CODECOPY else
 if b = 0X3c then Memory EXTCODECOPY else
 if b = 0X59 then Memory MSIZE else
 if b = 0X80 then Dup 0 else
 if b = 0X81 then Dup 1 else
 if b = 0X82 then Dup 2 else
 if b = 0X83 then Dup 3 else
 if b = 0X84 then Dup 4 else
 if b = 0X85 then Dup 5 else
 if b = 0X86 then Dup 6 else
 if b = 0X87 then Dup 7 else
 if b = 0X88 then Dup 8 else
 if b = 0X89 then Dup 9 else
 if b = 0X8a then Dup 10 else
 if b = 0X8b then Dup 11 else
 if b = 0X8c then Dup 12 else
 if b = 0X8d then Dup 13 else
 if b = 0X8e then Dup 14 else
 if b = 0X8f then Dup 15 else
 if b = 0X90 then Swap 0 else
 if b = 0X91 then Swap 1 else
 if b = 0X92 then Swap 2 else
 if b = 0X93 then Swap 3 else
 if b = 0X94 then Swap 4 else
 if b = 0X95 then Swap 5 else
 if b = 0X96 then Swap 6 else
 if b = 0X97 then Swap 7 else
 if b = 0X98 then Swap 8 else
 if b = 0X99 then Swap 9 else
 if b = 0X9a then Swap 10 else
 if b = 0X9b then Swap 11 else
 if b = 0X9c then Swap 12 else
 if b = 0X9d then Swap 13 else
 if b = 0X9e then Swap 14 else
 if b = 0X9f then Swap 15 else
 if b = 0X30 then Info ADDRESS else
 if b = 0X31 then Info BALANCE else
 if b = 0X32 then Info ORIGIN else
 if b = 0X34 then Info CALLVALUE else
 if b = 0X36 then Info CALLDATASIZE else
 if b = 0X33 then Info CALLER else
 if b = 0X38 then Info CODESIZE else
 if b = 0X3a then Info GASPRICE else
 if b = 0X3b then Info EXTCODESIZE else
 if b = 0X40 then Info BLOCKHASH else
 if b = 0X41 then Info COINBASE else
 if b = 0X42 then Info TIMESTAMP else
 if b = 0X43 then Info NUMBER else
 if b = 0X44 then Info DIFFICULTY else
 if b = 0X45 then Info GASLIMIT else
 if b = 0X5a then Info GAS else
 if b = 0X01 then Arith ADD else
 if b = 0X02 then Arith MUL else
 if b = 0X03 then Arith SUB else
 if b = 0X04 then Arith DIV else
 if b = 0X06 then Arith MOD else
 if b = 0X08 then Arith ADDMOD else
 if b = 0X09 then Arith MULMOD else
 if b = 0X0a then Arith EXP else
 if b = 0X11 then Arith inst_GT else
 if b = 0X10 then Arith inst_LT else
 if b = 0X14 then Arith inst_EQ else
 if b = 0X15 then Arith ISZERO else
 if b = 0X20 then Arith SHA3 else
 if b = 0X05 then Sarith SDIV else
 if b = 0X07 then Sarith SMOD else
 if b = 0X13 then Sarith SGT else
 if b = 0X12 then Sarith SLT else
 if b = 0X0b then Sarith SIGNEXTEND else
 Unknown b

val inst_to_byte : inst -> byte
let inst_to_byte inst = match inst with
| Unknown byte -> byte
| Bits b -> bits_inst_code b
| Sarith s -> sarith_inst_code s
| Arith a -> arith_inst_code a
| Info i -> info_inst_code i
| Dup d -> dup_inst_code d
| Memory m -> memory_inst_code m
| Storage s -> storage_inst_code s
| Pc p -> pc_inst_code p
| Stack s -> match index (stack_inst_code s) 0 with Nothing -> 0 | Just x -> x end 
| Swap s -> swap_inst_code s
| Log l -> log_inst_code l
| Misc m -> misc_inst_code m
end

val fix_push : list inst -> list inst
let rec fix_push lst = match lst with
 | [] -> []
 | Stack (PUSH_N lst) :: tl -> Stack (PUSH_N (List.map inst_to_byte (take (length lst) tl))) :: fix_push tl
 | a :: tl -> a :: fix_push tl
end

val bytelist_to_instlist : list byte -> list inst
let bytelist_to_instlist lst = fix_push (map byte_to_inst lst)

type stack_hint =
 | NoHint
 | CreateAddress of address
 | ReturnTo of integer * integer

type global_state =
 | Continue of world_state * list (world_state * variable_ctx * constant_ctx * stack_hint) * world_state * constant_ctx * instruction_result
 | Finished of world_state

let get_hint = function
 | Just (a,b) -> ReturnTo a b
 | Nothing -> NoHint
end

let set_account_code acc bytes =
  let code (i:integer) = if i < 0 then Nothing else List.index (bytelist_to_instlist bytes) (natFromInteger i) in
  <| acc with account_code = <|
       program_annotation = (fun _ -> []);
       program_length = integerFromNat (List.length bytes);
       program_content = code |> |>

(*

todo
 * refund gas

*)

val update_world : world_state -> address -> account -> world_state
let update_world state a_addr n_acc a = if a = a_addr then n_acc else state a

let update_tr state addr value =
  let acc = state addr in
  let acc = <| acc with account_balance = acc.account_balance - value; account_nonce = acc.account_nonce+1 |> in
  update_world state addr acc


let update_call state addr args =
  let state = update_tr state addr args.callarg_value in
  let to_acc = state args.callarg_recipient in
  let to_acc = <| to_acc with account_balance = to_acc.account_balance + args.callarg_value |> in
  let state = update_world state args.callarg_recipient to_acc in
  state

let update_selfdestruct state addr =
  update_world state addr <| (state addr) with account_killed = true |>

let update_return state addr v =
  update_world state addr <| (state addr) with account_storage = v.vctx_storage |>

let next = function
 | Finished st -> Finished st
 | Continue orig stack state c res ->
    match res with
    | InstructionToEnvironment act v stuff ->
      match act with
      | ContractCall args ->
         let n_state = update_call state c.cctx_this args in
         let acc = n_state args.callarg_recipient in
         let cctx = <| cctx_this = args.callarg_recipient; cctx_program = (n_state args.callarg_code).account_code; cctx_hash_filter = c.cctx_hash_filter |> in
         let nv = start_env acc n_state args c.cctx_this v.vctx_origin v.vctx_block in
         Continue orig ((state,v,c,get_hint stuff)::stack) n_state cctx (InstructionContinue nv)
      | ContractDelegateCall args ->
         let n_state = update_call state c.cctx_this args in
         let acc = n_state args.callarg_recipient in
         let cctx = <| cctx_this = args.callarg_recipient; cctx_program = (n_state args.callarg_code).account_code; cctx_hash_filter = c.cctx_hash_filter |> in
         let nv = start_env acc n_state args c.cctx_this v.vctx_origin v.vctx_block in
         Continue orig ((state,v,c,get_hint stuff)::stack) n_state cctx (InstructionContinue nv)
      | ContractCreate args ->
         let n_state = update_tr state c.cctx_this args.createarg_value in
         let n_acc = n_state c.cctx_this in
         let addr = w256_to_address (keccak (word_rsplit256 (address_to_w256 c.cctx_this) ++ (word_rsplit256 n_acc.account_nonce))) in
         let acc = empty_account addr in
         let acc = set_account_code acc args.createarg_code in
         let acc = <| acc with account_balance = args.createarg_value |> in
         let cctx = <| cctx_this = addr; cctx_program = acc.account_code; cctx_hash_filter = c.cctx_hash_filter |> in
         let n_state = update_world n_state c.cctx_this acc in
         let nv = create_env acc n_state args.createarg_value [] 0 c.cctx_this v.vctx_origin v.vctx_block in
         Continue orig ((state,v,c,CreateAddress addr)::stack) n_state cctx (InstructionContinue nv)
      | ContractFail _ ->
         match stack with
         | [] -> Finished orig
         | (oldstate,v,c,_) :: rest ->
           let v = <| v with vctx_stack = 0::v.vctx_stack |> in
           Continue orig rest oldstate c (InstructionContinue v)
         end
      | ContractSuicide ->
         let n_state = update_selfdestruct state c.cctx_this in
         match stack with
         | [] -> Finished orig
         | (_,nv,c,_) :: rest ->
           let acc = n_state c.cctx_this in
           let nv = <| nv with vctx_stack = 1::nv.vctx_stack |> in
           let nv = vctx_update_from_world nv acc n_state v in
           Continue orig rest n_state c (InstructionContinue nv)
         end
      | ContractReturn bytes ->
         let n_state = update_return state c.cctx_this v in
         match stack with
         | [] -> Finished n_state
         | (_,nv,c,ReturnTo mem_start mem_size) :: rest -> 
           let acc = n_state c.cctx_this in
           let nv = <| v with vctx_stack = 1::nv.vctx_stack; vctx_memory = put_return_values nv.vctx_memory bytes mem_start mem_size |> in
           let nv = vctx_update_from_world nv acc n_state v in
           Continue orig rest n_state c (InstructionContinue nv)
         | (_,nv,c,CreateAddress new_addr) :: rest ->
           let new_acc = n_state new_addr in
           let new_acc = set_account_code new_acc bytes in
           let n_state addr = if addr = new_addr then new_acc else n_state addr in
           let acc = n_state c.cctx_this in
           let nv = <| nv with vctx_stack = address_to_w256 new_addr::nv.vctx_stack |> in
           let nv = vctx_update_from_world nv acc n_state v in
           Continue orig rest n_state c (InstructionContinue nv)
         | _ -> Finished orig (* should be impossible *)
         end
      end
    | a -> Continue orig stack state c (next_state (fun _ -> ()) c a)
    end
end

let start_transaction tr state block =
  match tr.tr_to with
  | Nothing -> Finished state
  | Just addr ->
    let s_acc = state tr.tr_from in
    let s_acc = <| s_acc with account_nonce = s_acc.account_nonce + 1; account_balance = s_acc.account_balance - tr.tr_value |> in
    let n_state = update_world state tr.tr_from s_acc in
    let acc = state addr in
    let acc = <| acc with account_balance = acc.account_balance + tr.tr_value |> in
    let n_state = update_world n_state addr acc in
    let v = create_env acc n_state tr.tr_value tr.tr_data tr.tr_gas_limit tr.tr_from tr.tr_from block in
    let c = build_cctx acc in
    Continue state [] n_state c (InstructionContinue v)
end

