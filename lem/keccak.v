(* Generated by Lem from keccak.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(**)
(* Copyright 2016 Sami MÃ¤kelÃ¤ *)
(**)
(* Licensed under the Apache License; Version 2.0 (the "License"); *)
(* you may not use this file except in compliance with the License. *)
(* You may obtain a copy of the License at *)
(* *)
(*     http://www.apache.org/licenses/LICENSE-2.0 *)
(* *)
(* Unless required by applicable law or agreed to in writing; software *)
(* distributed under the License is distributed on an "AS IS" BASIS; *)
(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND; either express or implied. *)
(* See the License for the specific language governing permissions and *)
(* limitations under the License. *)

Require Import lem_pervasives.
Require Export lem_pervasives.

Require Import lem_word.
Require Export lem_word.

Require Import word8.
Require Export word8.

Require Import word256.
Require Export word256.


(*
definition "rotl64 (x :: 64 word) n = (word_rotl n x :: 64 word)"
*)

Definition word64 : Type :=  Z .
Definition word64_default: word64  := Z_default.
(* [?]: removed value specification. *)

Definition rotl64  (w : Z ) (n : nat )  : Z :=  ( w).
(* [?]: removed value specification. *)

Definition big   : Z :=  ((Zpred (Zpos (P_of_succ_nat 1)))).
(* [?]: removed value specification. *)

Definition keccakf_randc   : list (Z ):=  [].
(*
[(Zpred (Zpos (P_of_succ_nat 1)));
(Zpred (Zpos (P_of_succ_nat 32898))); big; big;(Zpred (Zpos (P_of_succ_nat 32907)));(Zpred (Zpos (P_of_succ_nat 2147483649))); big; big;(Zpred (Zpos (P_of_succ_nat 138)));(Zpred (Zpos (P_of_succ_nat 136)));(Zpred (Zpos (P_of_succ_nat 2147516425)));(Zpred (Zpos (P_of_succ_nat 2147483658)));(Zpred (Zpos (P_of_succ_nat 2147516555))); big; big; big; big; big;(Zpred (Zpos (P_of_succ_nat 32778))); big; big; big;(Zpred (Zpos (P_of_succ_nat 2147483649))); big]
.*)

(* [?]: removed value specification. *)

Definition keccakf_rotc   : list (nat ):=  [ 1; 3; 6; 10; 15; 21; 28; 36; 45; 55; 2; 14; 27; 41; 56; 8; 25; 43; 62; 18; 39; 61; 20; 44]
.
(* [?]: removed value specification. *)

Definition keccakf_piln   : list (nat ):=  [ 10; 7; 11; 17; 18; 3; 5; 16; 8; 21; 24; 4; 15; 23; 19; 13; 12; 2; 20; 14; 22; 9; 6; 1]
.
(* [?]: removed value specification. *)

Definition get  (lst : list (Z )) (n : nat )  : Z :=  match ( index lst n) with 
 | Some x => x
 | None =>(Zpred (Zpos (P_of_succ_nat 0)))
end.
(* [?]: removed value specification. *)

Definition get_n  (lst : list (nat )) (n : nat )  : nat :=  match ( index lst n) with 
 | Some x => x
 | None => 0
end.
(* [?]: removed value specification. *)

Definition setf  (lst : list (Z )) (n : nat ) (w : Z )  : list (Z ):= 
  if nat_ltb (List.length lst) n then  (@ List.app _) ((@ List.app _)lst (genlist (fun  _ : nat  =>(Zpred (Zpos (P_of_succ_nat 0)))) ( Coq.Init.Peano.minus (Coq.Init.Peano.minus(List.length lst) n)( 1)))) [w]
  else  (@ List.app _) ((@ List.app _)(take n lst) [w]) (drop (Coq.Init.Peano.plus n( 1)) lst).
(* [?]: removed value specification. *)

Definition theta1  (i : nat ) (st : list (word64 ))  : Z :=  (get st ( Coq.Init.Peano.plus i( 20))).
(* [?]: removed value specification. *)

Definition theta_t  (i : nat ) (bc : list (word64 ))  : Z :=  (rotl64 (get bc ( Coq.Numbers.Natural.Peano.NPeano.modulo( Coq.Init.Peano.plus i( 1))( 5)))( 1)).
(* [?]: removed value specification. *)

Definition theta  (st : list (word64 ))  : list (Z ):= 
  let bc := genlist (fun (i : nat ) => theta1 i st)( 5) in
  let t := genlist (fun (i : nat ) => theta_t i bc)( 5) in
  genlist (fun (ji : nat ) => (get t ( Coq.Numbers.Natural.Peano.NPeano.modulo ji( 5))))( 25).
(* [?]: removed value specification. *)

Definition rho_pi_inner  (t_st : (Z *list (word64 )) % type) (i : nat )  : (Z *list (word64 )) % type:= 
  let j := get_n keccakf_piln i in
  let bc := get ((@ snd _ _) t_st) j in
  (bc, setf ((@ snd _ _) t_st) j (rotl64 ((@ fst _ _) t_st) (get_n keccakf_rotc i))).
(* [?]: removed value specification. *)

Definition rho_pi_changes  (i : nat ) (t_st : (word64 *list (word64 )) % type)  : (word64 *list (word64 )) % type:=  List.fold_left rho_pi_inner (genlist (fun (x : nat ) => x) i) t_st.
(* [?]: removed value specification. *)

Definition rho_pi  (st : list (word64 ))  : list (word64 ):=  (@ snd _ _) (rho_pi_changes( 24) (get st( 1), st)).
(* [?]: removed value specification. *)

Definition chi_for_j  (st_slice : list (word64 ))  : list (Z ):= 
  genlist (fun (i : nat ) => ( (get st_slice ( Coq.Numbers.Natural.Peano.NPeano.modulo( Coq.Init.Peano.plus i( 2))( 5)))))( 5).
(* [?]: removed value specification. *)

Definition filterI {a : Type}  (lst : list a) (pred : nat  -> bool )  : list a:= 
  List.map (@ fst _ _) (List.filter (fun (p : (a*nat ) % type) => pred ((@ snd _ _) p)) (zip lst (genlist (fun (i : nat ) => i) (List.length lst)))).
(* [?]: removed value specification. *)

Definition chi  (st : list (Z ))  : list (Z ):= 
  lem_list.concat (genlist (fun (j : nat ) => chi_for_j (filterI st (fun (i : nat ) => nat_lteb (Coq.Init.Peano.mult j( 5)) i && nat_lteb i (Coq.Init.Peano.plus(Coq.Init.Peano.mult j( 5))( 5)))))( 5)).
(* [?]: removed value specification. *)

Definition iota  (r : nat ) (st : list (word64 ))  : list (word64 ):=  setf st( 0) ( (get keccakf_randc r)).
(* [?]: removed value specification. *)

Definition for_inner  (st : list (word64 )) (r : nat )  : list (word64 ):=  iota r (chi (rho_pi (theta st))).

Definition keccakf_rounds    :  nat :=  24.

Definition byte : Type :=  word8 .
Definition byte_default: byte  := word8_default.
(* [?]: removed value specification. *)

(*
Program Fixpoint boolList64_inner  (num : Z ) (rest : nat )  : list (bool ):= 
  if beq_nat rest( 0) then []
  else
    let checked := ( Coq.ZArith.Zpower.Zpower_nat((Zpred (Zpos (P_of_succ_nat 2)))) ( Coq.Init.Peano.minus rest( 1))) in
    let quo := Coq.ZArith.Zdiv.Zdiv num checked in
    let taken := Coq.ZArith.BinInt.Zmult quo checked in
    ( negb (Z.eqb quo((Zpred (Zpos (P_of_succ_nat 0)))))) :: boolList64_inner ( Coq.ZArith.BinInt.Zminus num taken) ( Coq.Init.Peano.minus rest( 1)).
(* [?]: removed value specification. *)

Definition boolListFromWord64  (w : Z )  : list (bool ):=  boolList64_inner w( 64).
*)
(* [?]: removed value specification. *)
Definition boolListFromWord64  (w : Z )  : list (bool ):=  [].

Program Fixpoint word_rsplit_aux  (lst : list (bool )) (n : nat )  : list (word8 ):=  match ( n) with 
 | 0 => []
 |S (n) => word8FromBoollist (take( 8) lst) :: word_rsplit_aux (drop( 8) lst) n
end.
(* [?]: removed value specification. *)

Definition word_rsplit  (w : Z )  : list (byte ):=  word_rsplit_aux (boolListFromWord64 w)( 8).
(* [?]: removed value specification. *)

Program Fixpoint word64FromBoollist  (lst : list (bool ))  : Z :=  match ( lst) with 
 | true :: lst => Coq.ZArith.BinInt.Zplus((Zpred (Zpos (P_of_succ_nat 1)))) (Coq.ZArith.BinInt.Zmult((Zpred (Zpos (P_of_succ_nat 2)))) (word64FromBoollist lst))
 | false :: lst => Coq.ZArith.BinInt.Zmult((Zpred (Zpos (P_of_succ_nat 2)))) (word64FromBoollist lst)
 | [] =>(Zpred (Zpos (P_of_succ_nat 0)))
end.
(* [?]: removed value specification. *)

Definition word_rcat_k  (lst : list (word8 ))  : Z :=  word64FromBoollist (lem_list.concat (List.map boolListFromWord8 lst)).
(* [?]: removed value specification. *)

Definition invert_endian  (w : Z )  : Z :=  word_rcat_k (List.rev (word_rsplit w)).
(* [?]: removed value specification. *)

Definition keccakf  (st : list (word64 ))  : list (word64 ):=  List.fold_left for_inner (genlist (fun (i : nat ) => i) keccakf_rounds) st.

Definition mdlen    :  nat :=  Coq.Numbers.Natural.Peano.NPeano.div( 256)( 8).
Definition rsiz    :  nat :=  Coq.Init.Peano.minus( 200) (Coq.Init.Peano.mult mdlen( 2)).
(* [?]: removed value specification. *)

Definition word8_to_word64  (w : word8 )  : Z :=  (Zpred (Zpos (P_of_succ_nat (word8ToNat w)))).
(* [?]: removed value specification. *)

Definition update_byte  (i : word8 ) (p : nat ) (st : list (word64 ))  : list (word64 ):=  setf st ( Coq.Numbers.Natural.Peano.NPeano.div p( 8)) ( ( (word8_to_word64 i))).
(* [?]: removed value specification. *)

Program Fixpoint sha3_update  (lst : list (word8 )) (pos : nat ) (st : list (word64 ))  : (nat *list (word64 )) % type:=  match ( lst) with 
 | [] => (pos, st)
 | c :: rest =>
    if ( nat_lteb pos rsiz) then sha3_update rest ( Coq.Init.Peano.plus pos( 1)) (update_byte c pos st)
   else sha3_update rest( 0) (keccakf (update_byte c pos st))
end.
(* [?]: removed value specification. *)

Definition keccak_final  (p : nat ) (st : list (word64 ))  : list (word8 ):= 
   let st0 := update_byte(word8FromNumeral 1) p st in
   let st1 := update_byte(word8FromNumeral 128) ( Coq.Init.Peano.minus rsiz( 1)) st0 in
   let st2 := take( 4) (keccakf st1) in
   lem_list.concat (List.map (fun (x : Z ) => List.rev (word_rsplit x)) st2).

Definition initial_st    :  list  word64 :=  genlist (fun  _ : nat  =>(Zpred (Zpos (P_of_succ_nat 0))))( 25).

Definition initial_pos    :  nat :=  0.
(* [?]: removed value specification. *)

Definition keccak'  (input : list (byte ))  : list (byte ):= 
   let mid := sha3_update input initial_pos initial_st in
   keccak_final ((@ fst _ _) mid) ((@ snd _ _) mid).

Definition w256 : Type :=  word256 .
Definition w256_default: w256  := word256_default.
(* [?]: removed value specification. *)

Definition list_fill_right  (filled : bool ) (target : nat ) (orig : list (bool ))  : list (bool ):= 
  if nat_gteb (List.length orig) target then orig else
  let filling_len := Coq.Init.Peano.minus target (List.length orig) in
  (@ List.app _) orig (replicate filling_len filled).
(* [?]: removed value specification. *)

Definition list_fill_left  (filled : bool ) (target : nat ) (orig : list (bool ))  : list (bool ):= 
  if nat_gteb (List.length orig) target then orig else
  let filling_len := Coq.Init.Peano.minus target (List.length orig) in
  (@ List.app _) (replicate filling_len filled) orig.
(* [?]: removed value specification. *)

Definition word_of_bytes  (lst : list (word8 ))  : word256 :=  word256FromBoollist
                          (list_fill_left false( 256)
                            (lem_list.concat (List.map boolListFromWord8 lst))).
(* [?]: removed value specification. *)

Definition keccak  (input : list (byte ))  : word256 :=  word_of_bytes (keccak' input).
