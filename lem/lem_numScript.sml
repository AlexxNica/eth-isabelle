(*Generated by Lem from num.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_boolTheory lem_basic_classesTheory integerTheory intReduce wordsTheory wordsLib;

val _ = numLib.prefer_num();



val _ = new_theory "lem_num"



(*open import Bool Basic_classes*)
(*open import {isabelle} `~~/src/HOL/Word/Word`*)
(*open import {hol} `integerTheory` `intReduce` `wordsTheory` `wordsLib`*)
(*open import {coq} `Coq.Numbers.BinNums` `Coq.ZArith.BinInt` `Coq.ZArith.Zpower` `Coq.ZArith.Zdiv` `Coq.ZArith.Zmax` `Coq.Numbers.Natural.Peano.NPeano`*) 

(*class inline ( Numeral 'a ) 
  val fromNumeral : numeral -> 'a 
end*)

(* ========================================================================== *)
(* Syntactic type-classes for common operations                               *)
(* ========================================================================== *)

(* Typeclasses can be used as a mean to overload constants like "+", "-", etc *)

val _ = Hol_datatype `
(*  'a *) NumNegate_class= <| 
  numNegate_method : 'a -> 'a 
|>`;


val _ = Hol_datatype `
(*  'a *) NumAbs_class= <| 
  abs_method : 'a -> 'a 
|>`;


val _ = Hol_datatype `
(*  'a *) NumAdd_class= <| 
  numAdd_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumMinus_class= <| 
  numMinus_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumMult_class= <| 
  numMult_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumPow_class= <| 
  numPow_method : 'a -> num -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumDivision_class= <| 
  numDivision_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumIntegerDivision_class= <| 
  div_method : 'a -> 'a -> 'a
|>`;



val _ = Hol_datatype `
(*  'a *) NumRemainder_class= <| 
  mod_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumSucc_class= <| 
  succ_method : 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumPred_class= <| 
  pred_method : 'a -> 'a
|>`;
 


(* ----------------------- *)
(* natural                 *)
(* ----------------------- *)

(* unbounded size natural numbers *)
(*type natural*)


(* ----------------------- *)
(* int                     *)
(* ----------------------- *)

(* bounded size integers with uncertain length *)

(*type int*)


(* ----------------------- *)
(* integer                 *)
(* ----------------------- *)

(* unbounded size integers *)

(*type integer*)

(* ----------------------- *)
(* bint                    *)
(* ----------------------- *)

(* TODO the bounded ints are only partially implemented, use with care. *)

(* 32 bit integers *)
(*type int32*) 

(* 64 bit integers *)
(*type int64*) 


(* ----------------------- *)
(* rational                *)
(* ----------------------- *)

(* unbounded size and precision rational numbers *)

(*type rational*) (* ???: better type for this in HOL? *)


(* ----------------------- *)
(* double                  *)
(* ----------------------- *)

(* double precision floating point (64 bits) *)

(*type float64*) (* ???: better type for this in HOL? *)

(*type float32*) (* ???: better type for this in HOL? *)


(* ========================================================================== *)
(* Binding the standard operations for the number types                       *)
(* ========================================================================== *)


(* ----------------------- *)
(* nat                     *)
(* ----------------------- *)

(*val natFromNumeral : numeral -> nat*)

(*val natEq : nat -> nat -> bool*)

(*val natLess : nat -> nat -> bool*)
(*val natLessEqual : nat -> nat -> bool*)
(*val natGreater : nat -> nat -> bool*)
(*val natGreaterEqual : nat -> nat -> bool*)

(*val natCompare : nat -> nat -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_nat_dict= (<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;


(*val natAdd : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumAdd_nat_dict= (<|

  numAdd_method := (+)|>))`;


(*val natMinus : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumMinus_nat_dict= (<|

  numMinus_method := (-)|>))`;


(*val natSucc : nat -> nat*)
(*let natSucc n=  (Instance_Num_NumAdd_nat.+) n 1*)
val _ = Define `
(instance_Num_NumSucc_nat_dict= (<|

  succ_method := SUC|>))`;


(*val natPred : nat -> nat*)
val _ = Define `
(instance_Num_NumPred_nat_dict= (<|

  pred_method := PRE|>))`;


(*val natMult : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumMult_nat_dict= (<|

  numMult_method := ( * )|>))`;


(*val natDiv : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumIntegerDivision_nat_dict= (<|

  div_method := (DIV)|>))`;


val _ = Define `
(instance_Num_NumDivision_nat_dict= (<|

  numDivision_method := (DIV)|>))`;


(*val natMod : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumRemainder_nat_dict= (<|

  mod_method := (MOD)|>))`;



(*val gen_pow_aux : forall 'a. ('a -> 'a -> 'a) -> 'a -> 'a -> nat -> 'a*)
 val _ = Define `
 (gen_pow_aux (mul : 'a -> 'a -> 'a) (a : 'a) (b : 'a) (e : num)=   
 ((case e of
       0 => a (* cannot happen, call discipline guarentees e >= 1 *)
     | (SUC 0) => mul a b
     | (  (SUC(SUC e'))) => let e'' = (e DIV( 2 : num)) in
                   let a' = (if (e MOD( 2 : num)) =( 0 : num) then a else mul a b) in
                   gen_pow_aux mul a' (mul b b) e''
   )))`;

       
val _ = Define `
 (gen_pow (one1 : 'a) (mul : 'a -> 'a -> 'a) (b : 'a) (e : num) : 'a=  
  (if e <( 0 : num) then one1 else 
  if (e =( 0 : num)) then one1 else gen_pow_aux mul one1 b e))`;


(*val natPow : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumPow_nat_dict= (<|

  numPow_method := ( ** )|>))`;


(*val natMin : nat -> nat -> nat*)

(*val natMax : nat -> nat -> nat*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_nat_dict= (<|

  max_method := MAX;

  min_method := MIN|>))`;



(* ----------------------- *)
(* natural                 *)
(* ----------------------- *)

(*val naturalFromNumeral : numeral -> natural*)

(*val naturalEq : natural -> natural -> bool*)

(*val naturalLess : natural -> natural -> bool*)
(*val naturalLessEqual : natural -> natural -> bool*)
(*val naturalGreater : natural -> natural -> bool*)
(*val naturalGreaterEqual : natural -> natural -> bool*)

(*val naturalCompare : natural -> natural -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_Num_natural_dict= (<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;


(*val naturalAdd : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumAdd_Num_natural_dict= (<|

  numAdd_method := (+)|>))`;


(*val naturalMinus : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumMinus_Num_natural_dict= (<|

  numMinus_method := (-)|>))`;


(*val naturalSucc : natural -> natural*)
(*let naturalSucc n=  (Instance_Num_NumAdd_Num_natural.+) n 1*)
val _ = Define `
(instance_Num_NumSucc_Num_natural_dict= (<|

  succ_method := SUC|>))`;


(*val naturalPred : natural -> natural*)
val _ = Define `
(instance_Num_NumPred_Num_natural_dict= (<|

  pred_method := PRE|>))`;


(*val naturalMult : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumMult_Num_natural_dict= (<|

  numMult_method := ( * )|>))`;



(*val naturalPow : natural -> nat -> natural*)

val _ = Define `
(instance_Num_NumPow_Num_natural_dict= (<|

  numPow_method := ( ** )|>))`;


(*val naturalDiv : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumIntegerDivision_Num_natural_dict= (<|

  div_method := (DIV)|>))`;


val _ = Define `
(instance_Num_NumDivision_Num_natural_dict= (<|

  numDivision_method := (DIV)|>))`;


(*val naturalMod : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumRemainder_Num_natural_dict= (<|

  mod_method := (MOD)|>))`;


(*val naturalMin : natural -> natural -> natural*)

(*val naturalMax : natural -> natural -> natural*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_Num_natural_dict= (<|

  max_method := MAX;

  min_method := MIN|>))`;



(* ----------------------- *)
(* int                     *)
(* ----------------------- *)

(*val intFromNumeral : numeral -> int*)

(*val intEq : int -> int -> bool*)

(*val intLess : int -> int -> bool*)
(*val intLessEqual : int -> int -> bool*)
(*val intGreater : int -> int -> bool*)
(*val intGreaterEqual : int -> int -> bool*)

(*val intCompare : int -> int -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_Num_int_dict= (<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;


(*val intNegate : int -> int*)

val _ = Define `
(instance_Num_NumNegate_Num_int_dict= (<|

  numNegate_method := (\ i. ~ i)|>))`;


(*val intAbs : int -> int*) (* TODO: check *)

val _ = Define `
(instance_Num_NumAbs_Num_int_dict= (<|

  abs_method := ABS|>))`;


(*val intAdd : int -> int -> int*)

val _ = Define `
(instance_Num_NumAdd_Num_int_dict= (<|

  numAdd_method := (+)|>))`;


(*val intMinus : int -> int -> int*)

val _ = Define `
(instance_Num_NumMinus_Num_int_dict= (<|

  numMinus_method := (-)|>))`;


(*val intSucc : int -> int*)
val _ = Define `
(instance_Num_NumSucc_Num_int_dict= (<|

  succ_method := (\ n. n +( 1 : int))|>))`;


(*val intPred : int -> int*)
val _ = Define `
(instance_Num_NumPred_Num_int_dict= (<|

  pred_method := (\ n. n -( 1 : int))|>))`;


(*val intMult : int -> int -> int*)

val _ = Define `
(instance_Num_NumMult_Num_int_dict= (<|

  numMult_method := ( * )|>))`;



(*val intPow : int -> nat -> int*)

val _ = Define `
(instance_Num_NumPow_Num_int_dict= (<|

  numPow_method := ( ** )|>))`;


(*val intDiv : int -> int -> int*)

val _ = Define `
(instance_Num_NumIntegerDivision_Num_int_dict= (<|

  div_method := (/)|>))`;


val _ = Define `
(instance_Num_NumDivision_Num_int_dict= (<|

  numDivision_method := (/)|>))`;


(*val intMod : int -> int -> int*)

val _ = Define `
(instance_Num_NumRemainder_Num_int_dict= (<|

  mod_method := (%)|>))`;


(*val intMin : int -> int -> int*)

(*val intMax : int -> int -> int*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_Num_int_dict= (<|

  max_method := int_max;

  min_method := int_min|>))`;


(* ----------------------- *)
(* int32                   *)
(* ----------------------- *)
(*val int32FromNumeral : numeral -> int32*)

(*val int32Eq : int32 -> int32 -> bool*)

(*val int32Less : int32 -> int32 -> bool*)
(*val int32LessEqual : int32 -> int32 -> bool*)
(*val int32Greater : int32 -> int32 -> bool*)
(*val int32GreaterEqual : int32 -> int32 -> bool*)

(*val int32Compare : int32 -> int32 -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_Num_int32_dict= (<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;


(*val int32Negate : int32 -> int32*)

val _ = Define `
(instance_Num_NumNegate_Num_int32_dict= (<|

  numNegate_method := (\ i. ((- i) : word32))|>))`;


(*val int32Abs : int32 -> int32*)
val _ = Define `
 (int32Abs i=  (if((n2w 0) : word32) <= i then i else ((- i) : word32)))`;


val _ = Define `
(instance_Num_NumAbs_Num_int32_dict= (<|

  abs_method := int32Abs|>))`;



(*val int32Add : int32 -> int32 -> int32*)

val _ = Define `
(instance_Num_NumAdd_Num_int32_dict= (<|

  numAdd_method := (\ i1 i2. ((word_add i1 i2) : word32))|>))`;


(*val int32Minus : int32 -> int32 -> int32*)

val _ = Define `
(instance_Num_NumMinus_Num_int32_dict= (<|

  numMinus_method := (\ i1 i2. ((word_sub i1 i2) : word32))|>))`;


(*val int32Succ : int32 -> int32*)

val _ = Define `
(instance_Num_NumSucc_Num_int32_dict= (<|

  succ_method := (\ n.  ((word_add n (((n2w 1) : word32))) : word32))|>))`;


(*val int32Pred : int32 -> int32*)
val _ = Define `
(instance_Num_NumPred_Num_int32_dict= (<|

  pred_method := (\ n.  ((word_sub n (((n2w 1) : word32))) : word32))|>))`;


(*val int32Mult : int32 -> int32 -> int32*)

val _ = Define `
(instance_Num_NumMult_Num_int32_dict= (<|

  numMult_method := (\ i1 i2. ((word_mul i1 i2) : word32))|>))`;



(*val int32Pow : int32 -> nat -> int32*)
val _ = Define `
 (int32Pow=  (gen_pow(((n2w 1) : word32)) (\ i1 i2. ((word_mul i1 i2) : word32))))`;


val _ = Define `
(instance_Num_NumPow_Num_int32_dict= (<|

  numPow_method := int32Pow|>))`;


(*val int32Div : int32 -> int32 -> int32*)

val _ = Define `
(instance_Num_NumIntegerDivision_Num_int32_dict= (<|

  div_method := (\ i1 i2. ((word_div i1 i2) : word32))|>))`;


val _ = Define `
(instance_Num_NumDivision_Num_int32_dict= (<|

  numDivision_method := (\ i1 i2. ((word_div i1 i2) : word32))|>))`;


(*val int32Mod : int32 -> int32 -> int32*)

val _ = Define `
(instance_Num_NumRemainder_Num_int32_dict= (<|

  mod_method := (\ i1 i2. ((word_mod i1 i2) : word32))|>))`;


(*val int32Min : int32 -> int32 -> int32*)

(*val int32Max : int32 -> int32 -> int32*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_Num_int32_dict= (<|

  max_method := word_smax;

  min_method := word_smin|>))`;




(* ----------------------- *)
(* int64                   *)
(* ----------------------- *)
(*val int64FromNumeral : numeral -> int64*)

(*val int64Eq : int64 -> int64 -> bool*)

(*val int64Less : int64 -> int64 -> bool*)
(*val int64LessEqual : int64 -> int64 -> bool*)
(*val int64Greater : int64 -> int64 -> bool*)
(*val int64GreaterEqual : int64 -> int64 -> bool*)

(*val int64Compare : int64 -> int64 -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_Num_int64_dict= (<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;


(*val int64Negate : int64 -> int64*)

val _ = Define `
(instance_Num_NumNegate_Num_int64_dict= (<|

  numNegate_method := (\ i. ((- i) : word64))|>))`;


(*val int64Abs : int64 -> int64*)
val _ = Define `
 (int64Abs i=  (if((n2w 0) : word64) <= i then i else ((- i) : word64)))`;


val _ = Define `
(instance_Num_NumAbs_Num_int64_dict= (<|

  abs_method := int64Abs|>))`;



(*val int64Add : int64 -> int64 -> int64*)

val _ = Define `
(instance_Num_NumAdd_Num_int64_dict= (<|

  numAdd_method := (\ i1 i2. ((word_add i1 i2) : word64))|>))`;


(*val int64Minus : int64 -> int64 -> int64*)

val _ = Define `
(instance_Num_NumMinus_Num_int64_dict= (<|

  numMinus_method := (\ i1 i2. ((word_sub i1 i2) : word64))|>))`;


(*val int64Succ : int64 -> int64*)

val _ = Define `
(instance_Num_NumSucc_Num_int64_dict= (<|

  succ_method := (\ n.  ((word_add n (((n2w 1) : word64))) : word64))|>))`;


(*val int64Pred : int64 -> int64*)
val _ = Define `
(instance_Num_NumPred_Num_int64_dict= (<|

  pred_method := (\ n.  ((word_sub n (((n2w 1) : word64))) : word64))|>))`;


(*val int64Mult : int64 -> int64 -> int64*)

val _ = Define `
(instance_Num_NumMult_Num_int64_dict= (<|

  numMult_method := (\ i1 i2. ((word_mul i1 i2) : word64))|>))`;



(*val int64Pow : int64 -> nat -> int64*)
val _ = Define `
 (int64Pow=  (gen_pow(((n2w 1) : word64)) (\ i1 i2. ((word_mul i1 i2) : word64))))`;


val _ = Define `
(instance_Num_NumPow_Num_int64_dict= (<|

  numPow_method := int64Pow|>))`;


(*val int64Div : int64 -> int64 -> int64*)

val _ = Define `
(instance_Num_NumIntegerDivision_Num_int64_dict= (<|

  div_method := (\ i1 i2. ((word_div i1 i2) : word64))|>))`;


val _ = Define `
(instance_Num_NumDivision_Num_int64_dict= (<|

  numDivision_method := (\ i1 i2. ((word_div i1 i2) : word64))|>))`;


(*val int64Mod : int64 -> int64 -> int64*)

val _ = Define `
(instance_Num_NumRemainder_Num_int64_dict= (<|

  mod_method := (\ i1 i2. ((word_mod i1 i2) : word64))|>))`;


(*val int64Min : int64 -> int64 -> int64*)

(*val int64Max : int64 -> int64 -> int64*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_Num_int64_dict= (<|

  max_method := word_smax;

  min_method := word_smin|>))`;



(* ----------------------- *)
(* integer                 *)
(* ----------------------- *)

(*val integerFromNumeral : numeral -> integer*)

(*val integerEq : integer -> integer -> bool*)

(*val integerLess : integer -> integer -> bool*)
(*val integerLessEqual : integer -> integer -> bool*)
(*val integerGreater : integer -> integer -> bool*)
(*val integerGreaterEqual : integer -> integer -> bool*)

(*val integerCompare : integer -> integer -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_Num_integer_dict= (<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;


(*val integerNegate : integer -> integer*)

val _ = Define `
(instance_Num_NumNegate_Num_integer_dict= (<|

  numNegate_method := (\ i. ~ i)|>))`;


(*val integerAbs : integer -> integer*) (* TODO: check *)

val _ = Define `
(instance_Num_NumAbs_Num_integer_dict= (<|

  abs_method := ABS|>))`;


(*val integerAdd : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumAdd_Num_integer_dict= (<|

  numAdd_method := (+)|>))`;


(*val integerMinus : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumMinus_Num_integer_dict= (<|

  numMinus_method := (-)|>))`;


(*val integerSucc : integer -> integer*)
val _ = Define `
(instance_Num_NumSucc_Num_integer_dict= (<|

  succ_method := (\ n. n +( 1 : int))|>))`;


(*val integerPred : integer -> integer*)
val _ = Define `
(instance_Num_NumPred_Num_integer_dict= (<|

  pred_method := (\ n. n -( 1 : int))|>))`;


(*val integerMult : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumMult_Num_integer_dict= (<|

  numMult_method := ( * )|>))`;



(*val integerPow : integer -> nat -> integer*)

val _ = Define `
(instance_Num_NumPow_Num_integer_dict= (<|

  numPow_method := ( ** )|>))`;


(*val integerDiv : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumIntegerDivision_Num_integer_dict= (<|

  div_method := (/)|>))`;


val _ = Define `
(instance_Num_NumDivision_Num_integer_dict= (<|

  numDivision_method := (/)|>))`;


(*val integerMod : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumRemainder_Num_integer_dict= (<|

  mod_method := (%)|>))`;


(*val integerMin : integer -> integer -> integer*)

(*val integerMax : integer -> integer -> integer*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_Num_integer_dict= (<|

  max_method := int_max;

  min_method := int_min|>))`;




(* ========================================================================== *)
(* Translation between number types                                           *)
(* ========================================================================== *)

(******************)
(* integerFrom... *)
(******************)

(*val integerFromInt : int -> integer*)


(*val integerFromNat : nat -> integer*)

(*val integerFromNatural : natural -> integer*)


(*val integerFromInt32 : int32 -> integer*)


(*val integerFromInt64 : int64 -> integer*)


(******************)
(* naturalFrom... *)
(******************)

(*val naturalFromNat : nat -> natural*)

(*val naturalFromInteger : integer -> natural*)


(******************)
(* intFrom ...    *)
(******************)

(*val intFromInteger : integer -> int*)

(*val intFromNat : nat -> int*)


(******************)
(* natFrom ...    *)
(******************)

(*val natFromNatural : natural -> nat*)

(*val natFromInt : int -> nat*)


(******************)
(* int32From ...  *)
(******************)

(*val int32FromNat : nat -> int32*)

(*val int32FromNatural : natural -> int32*)

(*val int32FromInteger : integer -> int32*)
val _ = Define `
 (int32FromInteger i=  (
  let abs_int32 = (((n2w (Num (ABS i))) : word32)) in
  if (i <( 0 : int)) then (((- abs_int32) : word32)) else abs_int32 
))`;


(*val int32FromInt : int -> int32*)
val _ = Define `
 (int32FromInt i=  (int32FromInteger ( i)))`;



(*val int32FromInt64 : int64 -> int32*)
(*let int32FromInt64 i=  int32FromInteger (integerFromInt64 i)*)




(******************)
(* int64From ...  *)
(******************)

(*val int64FromNat : nat -> int64*)

(*val int64FromNatural : natural -> int64*)

(*val int64FromInteger : integer -> int64*)
val _ = Define `
 (int64FromInteger i=  (
  let abs_int64 = (((n2w (Num (ABS i))) : word64)) in
  if (i <( 0 : int)) then (((- abs_int64) : word64)) else abs_int64 
))`;


(*val int64FromInt : int -> int64*)
val _ = Define `
 (int64FromInt i=  (int64FromInteger ( i)))`;



(*val int64FromInt32 : int32 -> int64*)
(*let int64FromInt32 i=  int64FromInteger (integerFromInt32 i)*)


(******************)
(* what's missing *)
(******************)

(*val naturalFromInt : int -> natural*)
(*val naturalFromInt32 : int32 -> natural*)
(*val naturalFromInt64 : int64 -> natural*)


(*val intFromNatural : natural -> int*)
(*val intFromInt32 : int32 -> int*)
(*val intFromInt64 : int64 -> int*)

(*val natFromInteger : integer -> nat*)
(*val natFromInt32 : int32 -> nat*)
(*val natFromInt64 : int64 -> nat*)
val _ = export_theory()

