chapter {* Generated by Lem from word32.lem. *}

theory "Word32" 

imports 
 	 Main
	 "Lem_pervasives" 
	 "Lem_word" 

begin 

(*
  Copyright 2016 Sami MÃ¤kelÃ¤

   Licensed under the Apache License, Version 2.0 (the License);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an AS IS BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*)

(*open import Pervasives*)
(*open import Word*)

(*type word32 = W32 of bool * list bool*)

(* perhaps should truncate here? *)
(*val bs_to_w32 : bitSequence -> word32*)
(*let bs_to_w32 seq=  match resizeBitSeq (Just 32) seq with
 | BitSeq _ s b -> W32 s b
end*)

(*val w32_to_bs : word32 -> bitSequence*)
(*let w32_to_bs (W32 s b)=  BitSeq (Just 32) s b*)

(*val word32BinTest : forall 'a. (bitSequence -> bitSequence -> 'a) -> word32 -> word32 -> 'a*)
definition word32BinTest  :: "(bitSequence \<Rightarrow> bitSequence \<Rightarrow> 'a)\<Rightarrow> 32 word \<Rightarrow> 32 word \<Rightarrow> 'a "  where 
     " word32BinTest binop w1 w2 = ( binop ((\<lambda> w .  bitSeqFromInteger (Some 32) (sint w)) w1) ((\<lambda> w .  bitSeqFromInteger (Some 32) (sint w)) w2))"


(*val word32BinOp : (bitSequence -> bitSequence -> bitSequence) -> word32 -> word32 -> word32*)
definition word32BinOp  :: "(bitSequence \<Rightarrow> bitSequence \<Rightarrow> bitSequence)\<Rightarrow> 32 word \<Rightarrow> 32 word \<Rightarrow> 32 word "  where 
     " word32BinOp binop w1 w2 = ( (\<lambda> w .  word_of_int (integerFromBitSeq w)) (binop ((\<lambda> w .  bitSeqFromInteger (Some 32) (sint w)) w1) ((\<lambda> w .  bitSeqFromInteger (Some 32) (sint w)) w2)))"


(*val word32NatOp : (bitSequence -> nat -> bitSequence) -> word32 -> nat -> word32*)
definition word32NatOp  :: "(bitSequence \<Rightarrow> nat \<Rightarrow> bitSequence)\<Rightarrow> 32 word \<Rightarrow> nat \<Rightarrow> 32 word "  where 
     " word32NatOp binop w1 n = ( (\<lambda> w .  word_of_int (integerFromBitSeq w)) (binop ((\<lambda> w .  bitSeqFromInteger (Some 32) (sint w)) w1) n))"


(*val word32UnaryOp : (bitSequence -> bitSequence) -> word32 -> word32*)
definition word32UnaryOp  :: "(bitSequence \<Rightarrow> bitSequence)\<Rightarrow> 32 word \<Rightarrow> 32 word "  where 
     " word32UnaryOp op1 w = ( (\<lambda> w .  word_of_int (integerFromBitSeq w)) (op1 ((\<lambda> w .  bitSeqFromInteger (Some 32) (sint w)) w)))"


(*val size32 : integer*)
definition size32  :: " int "  where 
     " size32 = (( 2 :: int) ^( 32 :: nat))"


(*val word32ToInteger : word32 -> integer*)
(*let word32ToInteger w=  integerFromBitSeq (w32_to_bs w)*)

(*val word32ToNatural : word32 -> natural*)
(*let word32ToNatural w=  naturalFromInteger ((Instance_Num_NumRemainder_Num_integer.mod) (word32ToInteger w) size32)*)

(*val word32FromInteger : integer -> word32*)
(*let word32FromInteger i=  bs_to_w32 (bitSeqFromInteger (Just 32) i)*)

(*val word32FromInt : int -> word32*)
(*let word32FromInt i=  bs_to_w32 (bitSeqFromInteger (Just 32) (integerFromInt i))*)

(*val word32FromNatural : natural -> word32*)
definition word32FromNatural  :: " nat \<Rightarrow> 32 word "  where 
     " word32FromNatural i = ( (\<lambda> i .  word_of_int ( i)) (int i))"


(*val word32FromNat : nat -> word32*)
definition word32FromNat  :: " nat \<Rightarrow> 32 word "  where 
     " word32FromNat i = ( (\<lambda> i .  word_of_int ( i)) (int i))"


(*val word32FromBoollist : list bool -> word32*)
(*let word32FromBoollist lst=  match bitSeqFromBoolList (List.reverse lst) with
 | Nothing -> bs_to_w32 0
 | Just a -> bs_to_w32 a
end*)

(*val boolListFromWord32 : word32 -> list bool*)
(*let boolListFromWord32 w=  List.reverse (boolListFrombitSeq 32 (w32_to_bs w))*)

(*val word32FromNumeral : numeral -> word32*)
(*let word32FromNumeral w=  bs_to_w32 (Instance_Num_Numeral_Word_bitSequence.fromNumeral w)*)

(*val w32Eq : word32 -> word32 -> bool*)
definition w32Eq  :: " 32 word \<Rightarrow> 32 word \<Rightarrow> bool "  where 
     " w32Eq = ( (op=))"


(*val w32Less : word32 -> word32 -> bool*)
(*let w32Less bs1 bs2=  word32BinTest  
  (Instance_Basic_classes_Ord_Word_bitSequence.<) bs1 bs2*)

(*val w32LessEqual : word32 -> word32 -> bool*)
(*let w32LessEqual bs1 bs2=  word32BinTest  
  (Instance_Basic_classes_Ord_Word_bitSequence.<=) bs1 bs2*)

(*val w32Greater : word32 -> word32 -> bool*)
(*let w32Greater bs1 bs2=  word32BinTest  
  (Instance_Basic_classes_Ord_Word_bitSequence.>) bs1 bs2*)

(*val w32GreaterEqual : word32 -> word32 -> bool*)
(*let w32GreaterEqual bs1 bs2=  word32BinTest  
  (Instance_Basic_classes_Ord_Word_bitSequence.>=) bs1 bs2*)

(*val w32Compare : word32 -> word32 -> ordering*)
(*let w32Compare bs1 bs2=  word32BinTest  
  Instance_Basic_classes_Ord_Word_bitSequence.compare bs1 bs2*)

definition instance_Basic_classes_Ord_Word32_word32_dict  :: "( 32 word)Ord_class "  where 
     " instance_Basic_classes_Ord_Word32_word32_dict = ((|

  compare_method = (genericCompare word_sless w32Eq),

  isLess_method = word_sless,

  isLessEqual_method = word_sle,

  isGreater_method = (\<lambda> x y. word_sless y x),

  isGreaterEqual_method = (\<lambda> x y. word_sle y x)|) )"


(*val word32Negate : word32 -> word32*)
(*let word32Negate=  word32UnaryOp  
  Instance_Num_NumNegate_Word_bitSequence.~*)

(*val word32Succ : word32 -> word32*)
(*let word32Succ=  word32UnaryOp  
  Instance_Num_NumSucc_Word_bitSequence.succ*)

(*val word32Pred : word32 -> word32*)
(*let word32Pred=  word32UnaryOp  
  Instance_Num_NumPred_Word_bitSequence.pred*)

(*val word32Lnot : word32 -> word32*)
(*let word32Lnot=  word32UnaryOp  
  Instance_Word_WordNot_Word_bitSequence.lnot*)

(*val word32Add : word32 -> word32 -> word32*)
(*let word32Add=  word32BinOp  
  (Instance_Num_NumAdd_Word_bitSequence.+)*)

(*val word32Minus : word32 -> word32 -> word32*)
(*let word32Minus=  word32BinOp  
  (Instance_Num_NumMinus_Word_bitSequence.-)*)

(*val word32Mult : word32 -> word32 -> word32*)
(*let word32Mult=  word32BinOp  
  ( Instance_Num_NumMult_Word_bitSequence.* )*)

(*val word32IntegerDivision : word32 -> word32 -> word32*)
(*let word32IntegerDivision=  word32BinOp  
  (Instance_Num_NumDivision_Word_bitSequence./)*)

(*val word32Division : word32 -> word32 -> word32*)
(*let word32Division=  word32BinOp  
  Instance_Num_NumIntegerDivision_Word_bitSequence.div*)

(*val word32Remainder : word32 -> word32 -> word32*)
(*let word32Remainder=  word32BinOp  
  (Instance_Num_NumRemainder_Word_bitSequence.mod)*)

(*val word32Land : word32 -> word32 -> word32*)
(*let word32Land=  word32BinOp  
  (Instance_Word_WordAnd_Word_bitSequence.land)*)

(*val word32Lor : word32 -> word32 -> word32*)
(*let word32Lor=  word32BinOp  
  (Instance_Word_WordOr_Word_bitSequence.lor)*)

(*val word32Lxor : word32 -> word32 -> word32*)
(*let word32Lxor=  word32BinOp  
  (Instance_Word_WordXor_Word_bitSequence.lxor)*)

(*val word32Min : word32 -> word32 -> word32*)
(*let word32Min=  word32BinOp (Instance_Basic_classes_OrdMaxMin_Word_bitSequence.min)*)

(*val word32Max : word32 -> word32 -> word32*)
(*let word32Max=  word32BinOp (Instance_Basic_classes_OrdMaxMin_Word_bitSequence.max)*)

(*val word32Power : word32 -> nat -> word32*)
(*let word32Power=  word32NatOp  
  ( Instance_Num_NumPow_Word_bitSequence.** )*)

(*val word32Asr : word32 -> nat -> word32*)
(*let word32Asr=  word32NatOp  
  (Instance_Word_WordAsr_Word_bitSequence.asr)*)

(*val word32Lsr : word32 -> nat -> word32*)
(*let word32Lsr=  word32NatOp  
  (Instance_Word_WordLsr_Word_bitSequence.lsr)*)

(*val word32Lsl : word32 -> nat -> word32*)
(*let word32Lsl=  word32NatOp  
  (Instance_Word_WordLsl_Word_bitSequence.lsl)*)


definition instance_Num_NumNegate_Word32_word32_dict  :: "( 32 word)NumNegate_class "  where 
     " instance_Num_NumNegate_Word32_word32_dict = ((|

  numNegate_method = (\<lambda> i. - i)|) )"


definition instance_Num_NumAdd_Word32_word32_dict  :: "( 32 word)NumAdd_class "  where 
     " instance_Num_NumAdd_Word32_word32_dict = ((|

  numAdd_method = (op+)|) )"


definition instance_Num_NumMinus_Word32_word32_dict  :: "( 32 word)NumMinus_class "  where 
     " instance_Num_NumMinus_Word32_word32_dict = ((|

  numMinus_method = (op-)|) )"


definition instance_Num_NumSucc_Word32_word32_dict  :: "( 32 word)NumSucc_class "  where 
     " instance_Num_NumSucc_Word32_word32_dict = ((|

  succ_method = (\<lambda> n. n + 1)|) )"


definition instance_Num_NumPred_Word32_word32_dict  :: "( 32 word)NumPred_class "  where 
     " instance_Num_NumPred_Word32_word32_dict = ((|

  pred_method = (\<lambda> n. n - 1)|) )"


definition instance_Num_NumMult_Word32_word32_dict  :: "( 32 word)NumMult_class "  where 
     " instance_Num_NumMult_Word32_word32_dict = ((|

  numMult_method = (op*)|) )"


definition instance_Num_NumPow_Word32_word32_dict  :: "( 32 word)NumPow_class "  where 
     " instance_Num_NumPow_Word32_word32_dict = ((|

  numPow_method = (op^)|) )"


definition instance_Num_NumIntegerDivision_Word32_word32_dict  :: "( 32 word)NumIntegerDivision_class "  where 
     " instance_Num_NumIntegerDivision_Word32_word32_dict = ((|

  div_method = (op div)|) )"


definition instance_Num_NumDivision_Word32_word32_dict  :: "( 32 word)NumDivision_class "  where 
     " instance_Num_NumDivision_Word32_word32_dict = ((|

  numDivision_method = (op div)|) )"


definition instance_Num_NumRemainder_Word32_word32_dict  :: "( 32 word)NumRemainder_class "  where 
     " instance_Num_NumRemainder_Word32_word32_dict = ((|

  mod_method = (op mod)|) )"


definition instance_Basic_classes_OrdMaxMin_Word32_word32_dict  :: "( 32 word)OrdMaxMin_class "  where 
     " instance_Basic_classes_OrdMaxMin_Word32_word32_dict = ((|

  max_method = max,

  min_method = min |) )"


definition instance_Word_WordNot_Word32_word32_dict  :: "( 32 word)WordNot_class "  where 
     " instance_Word_WordNot_Word32_word32_dict = ((|

  lnot_method = (\<lambda> w. (NOT w))|) )"


definition instance_Word_WordAnd_Word32_word32_dict  :: "( 32 word)WordAnd_class "  where 
     " instance_Word_WordAnd_Word32_word32_dict = ((|

  land_method = (op AND)|) )"


definition instance_Word_WordOr_Word32_word32_dict  :: "( 32 word)WordOr_class "  where 
     " instance_Word_WordOr_Word32_word32_dict = ((|

  lor_method = (op OR)|) )"


definition instance_Word_WordXor_Word32_word32_dict  :: "( 32 word)WordXor_class "  where 
     " instance_Word_WordXor_Word32_word32_dict = ((|

  lxor_method = (op XOR)|) )"


definition instance_Word_WordLsl_Word32_word32_dict  :: "( 32 word)WordLsl_class "  where 
     " instance_Word_WordLsl_Word32_word32_dict = ((|

  lsl_method = (op<<)|) )"


definition instance_Word_WordLsr_Word32_word32_dict  :: "( 32 word)WordLsr_class "  where 
     " instance_Word_WordLsr_Word32_word32_dict = ((|

  lsr_method = (op>>)|) )"


definition instance_Word_WordAsr_Word32_word32_dict  :: "( 32 word)WordAsr_class "  where 
     " instance_Word_WordAsr_Word32_word32_dict = ((|

  asr_method = (op>>>)|) )"


(*val word32UGT : word32 -> word32 -> bool*)
(*let word32UGT a b=  (Instance_Basic_classes_Ord_Num_natural.>) (word32ToNatural a) (word32ToNatural b)*)

(*val word32ULT : word32 -> word32 -> bool*)
(*let word32ULT a b=  (Instance_Basic_classes_Ord_Num_natural.<) (word32ToNatural a) (word32ToNatural b)*)

(*val word32UGE : word32 -> word32 -> bool*)
(*let word32UGE a b=  (Instance_Basic_classes_Ord_Num_natural.>=) (word32ToNatural a) (word32ToNatural b)*)

end
