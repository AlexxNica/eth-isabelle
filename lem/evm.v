(* Generated by Lem from evm.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

(*                                                                          *)
(* Copyright 2016 Sami MÃ¤kelÃ¤                                               *)
(* Copyright 2016 Yoichi Hirai                                              *)
(*                                                                          *)
(* Licensed under the Apache License, Version 2.0 (the "License");          *)
(* you may not use this file except in compliance with the License.         *)
(* You may obtain a copy of the License at                                  *)
(*                                                                          *)
(*     http://www.apache.org/licenses/LICENSE-2.0                           *)
(*                                                                          *)
(* Unless required by applicable law or agreed to in writing, software      *)
(* distributed under the License is distributed on an "AS IS" BASIS,        *)
(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)
(* See the License for the specific language governing permissions and      *)
(* limitations under the License.                                           *)

Require Import lem_pervasives.
Require Export lem_pervasives.

Require Import lem_word.
Require Export lem_word.

Require Import word256.
Require Export word256.

Require Import word160.
Require Export word160.

Require Import word8.
Require Export word8.

Require Import word4.
Require Export word4.

Require Import keccak.
Require Export keccak.


(* The frequently used machine word types are named here.  For example, address *)
(* is the type of 160-bit machine words.  The type w256 is the type of EVM machine words. *)

Definition address : Type :=  word160 .
Definition address_default: address  := word160_default.
(* [?]: removed value specification. *)

Definition sintFromW256   : word256  -> Z :=  word256ToInteger.
(* [?]: removed value specification. *)

Definition uint  (w : word256 )  : Z :=  (Zpred (Zpos (P_of_succ_nat (word256ToNatural w)))).
(* [?]: removed value specification. *)

Definition absnat  (w : word256 )  : nat :=  Zabs_nat ( (word256ToInteger w)).
(* [?]: removed value specification. *)

Definition byteFromNat   : nat  -> word8 :=  word8FromNat.
(* [?]: removed value specification. *)

Definition w256_of_bl   : list (bool ) -> word256 :=  word256FromBoollist.
(* [?]: removed value specification. *)

Definition w256_to_address  (w : word256 )  : word160 :=  word160FromNatural (word256ToNatural w).
(* [?]: removed value specification. *)

Definition address_to_w256  (w : word160 )  : word256 :=  word256FromNatural (word160ToNatural w).
(* [?]: removed value specification. *)

Definition w256_to_byte  (w : word256 )  : word8 :=  word8FromNatural (word256ToNatural w).
(* [?]: removed value specification. *)

Definition byte_to_w256  (w : word8 )  : word256 :=  word256FromNat (word8ToNat w).
(* [?]: removed value specification. *)

Definition word_rsplit256  (w : word256 )  : list (byte ):=  (word_rsplit_aux (boolListFromWord256 w)( 32)).
(* [?]: removed value specification. *)

Definition get_byte  (position : word256 ) (w : word256 )  : word256 := 
  if int_gteb (uint position)((Zpred (Zpos (P_of_succ_nat 32)))) then (word256FromNumeral 0) else
  match ( lem_list.index (word_rsplit256 w) (Zabs_nat ( (uint position)))) with 
  | None =>word256FromNumeral 0
  | Some a => byte_to_w256 a
  end.
(* [?]: removed value specification. *)

(* 
Program Fixpoint log2  (x : Z )  : Z := 
  if instance_Basic_classes_Ord_Num_integer.<= x 1 then 0
  else instance_Num_NumAdd_Num_integer.+ 1 Z.log2 (instance_Num_NumDivision_Num_integer./ x 2). *)
(* [?]: removed value specification. *)

Definition log256floor  (x : Z )  : Z :=  Coq.ZArith.Zdiv.Zdiv (Z.log2 x)((Zpred (Zpos (P_of_succ_nat 8)))).
(* [?]: removed value specification. *)

Program Fixpoint word_exp  (i : Z ) (n : nat )  : Z := 
  match ( n) with 
  | 0 =>(Zpred (Zpos (P_of_succ_nat 1)))
  |S (n) => Coq.ZArith.Zdiv.Zmod ( Coq.ZArith.BinInt.Zmult(word_exp i n) i) ( Coq.ZArith.Zpower.Zpower_nat((Zpred (Zpos (P_of_succ_nat 2))))( 256))
  end.
Definition ii {a : Type}  (x : a)  : a:=  x.

(* In EVM, the memory contains one byte for each machine word (offset). *)
(* The storage contains one machine word for each machine word (index). *)
(* As we will see, the memory is cleared for every invocation of smart contracts. *)
(* The storage is persistent for an account. *)

Definition memory : Type :=  w256  ->  byte .
Definition memory_default: memory  := (fun (x121 :  w256 ) => byte_default).
Definition storage : Type :=  w256  ->  w256 .
Definition storage_default: storage  := (fun (x120 :  w256 ) => w256_default).
(* [?]: removed value specification. *)

Program Fixpoint cut_memory_aux  (idx : word256 ) (n : nat ) (memory1 : word256  -> word8 )  : list (word8 ):=  match ( n) with 
  | 0 => []
  | S (n) => memory1 idx :: cut_memory_aux ( word256Add idx(word256FromNumeral 1)) n memory1
end.
(* [?]: removed value specification. *)


Definition cut_memory  (idx : word256 ) (n : word256 ) (memory1 : w256  -> byte )  : list (byte ):=  cut_memory_aux idx (word256ToNatural n) memory1.
(* [?]: removed value specification. *)

Program Fixpoint put_return_values_aux  (orig : word256  -> word8 ) (lst : list (word8 )) (b : Z ) (s : nat )  : word256  -> word8 :=  match ( s) with 
  | 0 => orig
  | S (s) =>
  match ( lst) with 
  | [] => orig
  | h :: t => put_return_values_aux (fun (addr : word256 ) => if classical_boolean_equivalence addr (word256FromInteger b) then h else orig addr) t ( Coq.ZArith.BinInt.Zplus b((Zpred (Zpos (P_of_succ_nat 1))))) s
  end
end.
(* [?]: removed value specification. *)


Definition put_return_values  (orig : w256  -> byte ) (lst : list (byte )) (b : Z ) (s : Z )  : w256  -> byte := 
  if int_lteb s((Zpred (Zpos (P_of_succ_nat 0)))) then orig else put_return_values_aux orig lst b (Zabs_nat s).
(* [?]: removed value specification. *)

Definition empty_storage  (addr : word256 )  : word256 := word256FromNumeral 0.

Record aenv : Type := {
  aenv_stack : list  w256 ;
  aenv_memory : memory ;
  aenv_storage : storage ;
  aenv_balance : address  ->  w256 ;
  aenv_caller : address ;
  aenv_value_sent : w256 ;
  aenv_data_sent : list  byte ;
  aenv_storage_at_call : storage ;
  aenv_balance_at_call : address  ->  w256 ;
  aenv_this : address ;
  aenv_origin : address 
}.
Notation "{[ r 'with' 'aenv_stack' := e ]}" := ({| aenv_stack := e; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_memory' := e ]}" := ({| aenv_memory := e; aenv_stack := aenv_stack r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_storage' := e ]}" := ({| aenv_storage := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_balance' := e ]}" := ({| aenv_balance := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_caller' := e ]}" := ({| aenv_caller := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_value_sent' := e ]}" := ({| aenv_value_sent := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_data_sent' := e ]}" := ({| aenv_data_sent := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_storage_at_call' := e ]}" := ({| aenv_storage_at_call := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_balance_at_call' := e ]}" := ({| aenv_balance_at_call := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_this := aenv_this r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_this' := e ]}" := ({| aenv_this := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_origin := aenv_origin r |}).
Notation "{[ r 'with' 'aenv_origin' := e ]}" := ({| aenv_origin := e; aenv_stack := aenv_stack r; aenv_memory := aenv_memory r; aenv_storage := aenv_storage r; aenv_balance := aenv_balance r; aenv_caller := aenv_caller r; aenv_value_sent := aenv_value_sent r; aenv_data_sent := aenv_data_sent r; aenv_storage_at_call := aenv_storage_at_call r; aenv_balance_at_call := aenv_balance_at_call r; aenv_this := aenv_this r |}).
Definition aenv_default: aenv  := {| aenv_stack := DAEMON; aenv_memory := memory_default; aenv_storage := storage_default; aenv_balance := (fun (x118 :  address ) => w256_default); aenv_caller := address_default; aenv_value_sent := w256_default; aenv_data_sent := DAEMON; aenv_storage_at_call := storage_default; aenv_balance_at_call := (fun (x119 :  address ) => w256_default); aenv_this := address_default; aenv_origin := address_default |}.

(* @{term aenv_balance} field keeps track of the balance of all accounts because the contract *)
(* under verification can send some Eth to other accounts.  To capture the effect of this, I chose to *)
(* keep track of the balances of the other contracts.  *)

(* @{term aenv_storage_at_call} and @{term aenv_balance_at_call} fields remember the states at the *)
(* time of the contract invocation.  These are used for rolling back the state after a failure. *)
(* Failures happen for example when the contract under verification jumps to a wrong destination, *)
(* or it runs out of gas. *)

(* @{term aenv_origin} might be the same as but might be different from @{term aenv_caller}. *)
(* An Ethereum transaction is started by an external account (that is, an account which does not *)
(* have codes but owned by somebody with a secret key).  @{term aenv_origin} denotes this external *)
(* account.  During a transaction, the origin first sends a message to an account, the receiver can *)
(* in turn call other accounts as well.  When the calls nest, @{term aenv_caller} points to the *)
(* immediate caller of the current invocation. *)


(* This section lists the EVM instructions and their byte representations. *)
(* I also introduce an assertion instruction, whose byte representation is empty. *)
(* The assertion instruction is a statement about the state of the EVM at *)
(* that position of the program. *)


(****** What used to be Instructions.thy ******)

(* In Isabelle/HOL, it is expensive to define a single inductive type *)
(* that contains all instructions.  When I do it, Isabelle/HOL automatically proves every *)
(* instruction is different from any other instruction, but this process has the computational *)
(* complexity of the square of the number of instructions.  Instead, I define multiple *)
(* smaller inductive types and unify them at the end.  *)


(* (delta, alpha) is the (consumption, production) on thae stack. *)
Definition stack_numbers : Type :=  ((Z  * Z ) % type).
Definition stack_numbers_default: stack_numbers  := (Z_default, Z_default).


(* subsection "Bit Operations" *)


(* The following clause defines a type called \textit{bits\_inst}. *)
(* The type has five elements.  It is automatically understood that nothing else *)
(* belongs to this type.  It is also understood that every one of these five elements *)
(* is different from any of the other four. *)

(* Some instructions have \textit{inst\_} in front because names like AND, *)
(* OR and XOR are taken by the machine word library. *)

(* The instructions have different arities.  They might consume some elements on the stack, *)
(* and produce some elements on the stack.  However, the arity of the instructions are not specified *)
(* in this section. *)

Inductive bits_inst : Type := 
| inst_AND: bits_inst  (* bitwise AND *)
| inst_OR: bits_inst   (* bitwise OR *)
| inst_XOR: bits_inst  (* bitwise exclusive or *)
| inst_NOT: bits_inst  (* bitwise negation *)
| BYTE: bits_inst .
Definition bits_inst_default: bits_inst  := inst_AND.
(* [?]: removed value specification. *)

Definition bits_inst_code  (inst1 : bits_inst )  : word8 :=  match ( inst1) with 
| inst_AND =>word8FromNumeral 22
| inst_OR =>word8FromNumeral 23
| inst_XOR =>word8FromNumeral 24
| inst_NOT =>word8FromNumeral 25
| BYTE =>word8FromNumeral 26
end.
(* [?]: removed value specification. *)

Definition bits_stack_nums  (inst1 : bits_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| inst_AND => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| inst_OR => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| inst_XOR => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| inst_NOT => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 1))))
| BYTE => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
end.

(* subsection "Signed Arithmetics" *)

(* More similar definitions follow.  Below are instructions for signed arithmetics.
The operations common to signed and unsigned are listed further below in the
Unsigned Arithmetics section. *)

Inductive sarith_inst : Type := 
| SDIV: sarith_inst  (* signed division *)
| SMOD: sarith_inst  (* signed modulo *)
| SGT: sarith_inst   (* signed greater-than *)
| SLT: sarith_inst   (* signed less-than *)
| SIGNEXTEND: sarith_inst .
Definition sarith_inst_default: sarith_inst  := SDIV.
(* [?]: removed value specification. *)

Definition sarith_inst_code  (inst1 : sarith_inst )  : word8 :=  match ( inst1) with 
| SDIV =>word8FromNumeral 5
| SMOD =>word8FromNumeral 7
| SGT =>word8FromNumeral 19
| SLT =>word8FromNumeral 18
| SIGNEXTEND =>word8FromNumeral 11
end.
(* [?]: removed value specification. *)

Definition sarith_inst_nums  (inst1 : sarith_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| SDIV => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| SMOD => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| SGT => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| SLT => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| SIGNEXTEND => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
end.

(* subsection "Unsigned Arithmetics" *)

(* The names GT, EQ and LT are taken in the Cmp library *)
(* (which will be used for AVL trees). *)

Inductive arith_inst : Type := 
| ADD: arith_inst  (* addition *)
| MUL: arith_inst  (* multiplication *)
| SUB: arith_inst  (* subtraction *)
| DIV: arith_inst  (* unsigned division *)
| MOD: arith_inst  (* unsigned modulo *)
| ADDMOD: arith_inst  (* addition under modulo *)
| MULMOD: arith_inst  (* multiplication under modulo *)
| EXP: arith_inst  (* exponentiation *)
| inst_GT: arith_inst  (* unsigned greater-than *)
| inst_EQ: arith_inst  (* equality *)
| inst_LT: arith_inst  (* unsigned less-than *)
| ISZERO: arith_inst  (* if zero, returns one *)
| SHA3: arith_inst .
Definition arith_inst_default: arith_inst  := ADD.
(* [?]: removed value specification. *)

Definition arith_inst_code  (inst1 : arith_inst )  : word8 :=  match ( inst1) with 
| ADD =>word8FromNumeral 1
| MUL =>word8FromNumeral 2
| SUB =>word8FromNumeral 3
| DIV =>word8FromNumeral 4
| MOD =>word8FromNumeral 6
| ADDMOD =>word8FromNumeral 8
| MULMOD =>word8FromNumeral 9
| EXP =>word8FromNumeral 10
| inst_GT =>word8FromNumeral 17
| inst_LT =>word8FromNumeral 16
| inst_EQ =>word8FromNumeral 20
| ISZERO =>word8FromNumeral 21
| SHA3 =>word8FromNumeral 32
end.
(* [?]: removed value specification. *)

Definition arith_inst_numbers  (inst1 : arith_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| ADD => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| MUL => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| SUB => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| DIV => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| MOD => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| ADDMOD => ((Zpred (Zpos (P_of_succ_nat 3))),(Zpred (Zpos (P_of_succ_nat 1))))
| MULMOD => ((Zpred (Zpos (P_of_succ_nat 3))),(Zpred (Zpos (P_of_succ_nat 1))))
| EXP => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| inst_GT => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| inst_LT => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| inst_EQ => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
| ISZERO => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 1))))
| SHA3 => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 1))))
end.


(* subsection "Informational Instructions" *)

Inductive info_inst : Type := 
    ADDRESS: info_inst  (* The address of the account currently running *)
  | BALANCE: info_inst  (* The Eth balance of the specified account *)
  | ORIGIN: info_inst  (* The address of the external account that started the transaction *)
  | CALLER: info_inst  (* The immediate caller of this invocation *)
  | CALLVALUE: info_inst  (* The Eth amount sent along this invocation *)
  | CALLDATASIZE: info_inst  (* The number of bytes sent along this invocation *)
  | CODESIZE: info_inst  (* The number of bytes in the code of the account currently running *)
  | GASPRICE: info_inst  (* The current gas price *)
  | EXTCODESIZE: info_inst  (* The size of a code of the specified account *)
  | BLOCKHASH: info_inst  (* The block hash of a specified block among the recent blocks. *)
  | COINBASE: info_inst  (* The address of the miner that validates the current block. *)
  | TIMESTAMP: info_inst  (* The date and time of the block. *)
  | NUMBER: info_inst  (* The block number *)
  | DIFFICULTY: info_inst  (* The current difficulty *)
  | GASLIMIT: info_inst  (* The current block gas limit *)
  | GAS: info_inst .
Definition info_inst_default: info_inst  := ADDRESS.
(* [?]: removed value specification. *)

Definition info_inst_code  (inst1 : info_inst )  : word8 :=  match ( inst1) with 
| ADDRESS =>word8FromNumeral 48
| BALANCE =>word8FromNumeral 49
| ORIGIN =>word8FromNumeral 50
| CALLVALUE =>word8FromNumeral 52
| CALLDATASIZE =>word8FromNumeral 54
| CALLER =>word8FromNumeral 51
| CODESIZE =>word8FromNumeral 56
| GASPRICE =>word8FromNumeral 58
| EXTCODESIZE =>word8FromNumeral 59
| BLOCKHASH =>word8FromNumeral 64
| COINBASE =>word8FromNumeral 65
| TIMESTAMP =>word8FromNumeral 66
| NUMBER =>word8FromNumeral 67
| DIFFICULTY =>word8FromNumeral 68
| GASLIMIT =>word8FromNumeral 69
| GAS =>word8FromNumeral 90
end.
(* [?]: removed value specification. *)

Definition info_inst_numbers  (inst1 : info_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| ADDRESS => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| BALANCE => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 1))))
| ORIGIN => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| CALLER => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| CALLVALUE => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| CALLDATASIZE => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| CODESIZE => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| GASPRICE => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| EXTCODESIZE => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 1))))
| BLOCKHASH => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 1))))
| COINBASE => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| TIMESTAMP => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| NUMBER => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| DIFFICULTY => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| GASLIMIT => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| GAS => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
end.

(* subsection "Duplicating Stack Elements" *)

(* There are sixteen instructions for duplicating a stack element.  These instructions take *)
(* a stack element and duplicate it on top of the stack. *)

Definition nibble : Type :=  word4 .
Definition nibble_default: nibble  := word4_default.

Definition dup_inst : Type :=  nibble .
Definition dup_inst_default: dup_inst  := nibble_default.
(* [?]: removed value specification. *)

Definition dup_inst_code  (m : word4 )  : word8 := 
  ( word8Add(word8FromInt (word4ToUInt m))(word8FromNumeral 128)).
(* [?]: removed value specification. *)

Definition dup_inst_numbers  (m : word4 )  : (Z *Z ) % type:=  ( Coq.ZArith.BinInt.Zplus(word4ToUInt m)((Zpred (Zpos (P_of_succ_nat 1)))), Coq.ZArith.BinInt.Zplus (word4ToUInt m)((Zpred (Zpos (P_of_succ_nat 2))))).

(* subsection {* Memory Operations *} *)

Inductive memory_inst : Type := 
| MLOAD: memory_inst  (* reading one machine word from the memory, beginning from the specified offset *)
| MSTORE: memory_inst  (* writing one machine word to the memory *)
| MSTORE8: memory_inst  (* writing one byte to the memory *)
| CALLDATACOPY: memory_inst  (* copying the caller's data to the memory *)
| CODECOPY: memory_inst  (* copying a part of the currently running code to the memory *)
| EXTCODECOPY: memory_inst  (* copying a part of the code of the specified account *)
| MSIZE: memory_inst .
Definition memory_inst_default: memory_inst  := MLOAD.
(* [?]: removed value specification. *)

Definition memory_inst_code  (inst1 : memory_inst )  : word8 :=  match ( inst1) with 
| MLOAD =>word8FromNumeral 81
| MSTORE =>word8FromNumeral 82
| MSTORE8 =>word8FromNumeral 83
| CALLDATACOPY =>word8FromNumeral 55
| CODECOPY =>word8FromNumeral 57
| EXTCODECOPY =>word8FromNumeral 60
| MSIZE =>word8FromNumeral 89
end.
(* [?]: removed value specification. *)

Definition memory_inst_numbers  (inst1 : memory_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| MLOAD        => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 1))))
| MSTORE       => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 0))))
| MSTORE8      => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 0))))
| CALLDATACOPY => ((Zpred (Zpos (P_of_succ_nat 3))),(Zpred (Zpos (P_of_succ_nat 0))))
| CODECOPY     => ((Zpred (Zpos (P_of_succ_nat 3))),(Zpred (Zpos (P_of_succ_nat 0))))
| EXTCODECOPY  => ((Zpred (Zpos (P_of_succ_nat 4))),(Zpred (Zpos (P_of_succ_nat 0))))
| MSIZE        => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
end.

(* subsection {* Storage Operations *} *)

Inductive storage_inst : Type := 
| SLOAD: storage_inst  (* reading one word from the storage *)
| SSTORE: storage_inst .
Definition storage_inst_default: storage_inst  := SLOAD.
(* [?]: removed value specification. *)

Definition storage_inst_code  (inst1 : storage_inst )  : word8 :=  match ( inst1) with 
| SLOAD =>word8FromNumeral 84
| SSTORE =>word8FromNumeral 85
end.
(* [?]: removed value specification. *)

Definition storage_inst_numbers  (inst1 : storage_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| SLOAD => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 1))))
| SSTORE => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 0))))
end.

(* subsection {* Program-Counter Instructions *} *)

Inductive pc_inst : Type := 
 | JUMP: pc_inst  (* jumping to the specified location in the code *)
 | JUMPI: pc_inst  (* jumping to the specified location in the code if a condition is met *)
 | PC: pc_inst  (* the current location in the code *)
 | JUMPDEST: pc_inst .
Definition pc_inst_default: pc_inst  := JUMP.
(* [?]: removed value specification. *)

Definition pc_inst_code  (inst1 : pc_inst )  : word8 :=  match ( inst1) with 
| JUMP =>word8FromNumeral 86
| JUMPI =>word8FromNumeral 87
| PC =>word8FromNumeral 88
| JUMPDEST =>word8FromNumeral 91
end.
(* [?]: removed value specification. *)

Definition pc_inst_numbers  (inst1 : pc_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| JUMP => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 0))))
| JUMPI => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 0))))
| PC => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| JUMPDEST => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 0))))
end.


(* subsection {* Stack Instructions *} *)

(* The PUSH instructions have longer byte representations than the other instructions *)
(* because they contain immediate values. *)
(* Here the immediate value is represented by a list of bytes.  Depending on the *)
(* length of the list, the PUSH operation takes different opcodes. *)

Inductive stack_inst : Type := 
  | POP: stack_inst  (* throwing away the topmost element of the stack *)
  | PUSH_N:  list  byte  -> stack_inst  (* pushing an element to the stack *)
  | CALLDATALOAD: stack_inst .
Definition stack_inst_default: stack_inst  := POP.
(* [?]: removed value specification. *)

Definition stack_inst_code  (inst1 : stack_inst )  : list (word8 ):=  match ( inst1) with 
| POP => [word8FromNumeral 80]
| PUSH_N lst =>
     if nat_ltb (List.length lst)( 1) then [word8FromNumeral 96;word8FromNumeral 0] (* this case should not exist *)
     else if nat_gtb (List.length lst)( 32) then [word8FromNumeral 96;word8FromNumeral 0] (* this case should not exist *)
     else  (@ List.app _)[ word8Add(byteFromNat (List.length lst))(word8FromNumeral 95)] lst
| CALLDATALOAD => [word8FromNumeral 53]
end.
(* [?]: removed value specification. *)

Definition stack_inst_numbers  (inst1 : stack_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| POP => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 0))))
| PUSH_N _ => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 1))))
| CALLDATALOAD => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 1))))
end.

Definition swap_inst : Type :=  nibble .
Definition swap_inst_default: swap_inst  := nibble_default.
(* [?]: removed value specification. *)

Definition swap_inst_code  (m : word4 )  : word8 := 
  ( word8Add(word8FromInt (word4ToUInt m))(word8FromNumeral 144)).
(* [?]: removed value specification. *)

Definition swap_inst_numbers  (m : word4 )  : (Z *Z ) % type:= 
( Coq.ZArith.BinInt.Zplus(word4ToUInt m)((Zpred (Zpos (P_of_succ_nat 2)))), Coq.ZArith.BinInt.Zplus (word4ToUInt m)((Zpred (Zpos (P_of_succ_nat 2))))).

(* subsection {* Logging Instructions *} *)

(* There are instructions for logging events with different number of arguments. *)

Inductive log_inst : Type := 
| LOG0: log_inst 
| LOG1: log_inst 
| LOG2: log_inst 
| LOG3: log_inst 
| LOG4: log_inst .
Definition log_inst_default: log_inst  := LOG0.
(* [?]: removed value specification. *)

Definition log_inst_code  (inst1 : log_inst )  : word8 :=  match ( inst1) with 
| LOG0 =>word8FromNumeral 160
| LOG1 =>word8FromNumeral 161
| LOG2 =>word8FromNumeral 162
| LOG3 =>word8FromNumeral 163
| LOG4 =>word8FromNumeral 164
end.
(* [?]: removed value specification. *)

Definition log_inst_numbers  (inst1 : log_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| LOG0 => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 0))))
| LOG1 => ((Zpred (Zpos (P_of_succ_nat 3))),(Zpred (Zpos (P_of_succ_nat 0))))
| LOG2 => ((Zpred (Zpos (P_of_succ_nat 4))),(Zpred (Zpos (P_of_succ_nat 0))))
| LOG3 => ((Zpred (Zpos (P_of_succ_nat 5))),(Zpred (Zpos (P_of_succ_nat 0))))
| LOG4 => ((Zpred (Zpos (P_of_succ_nat 6))),(Zpred (Zpos (P_of_succ_nat 0))))
end.

(* subsection {* Miscellaneous Instructions *} *)

(* This section contains the instructions that alter the account-wise control flow. *)
(* In other words, they cause communication between accounts (or at least interaction with *)
(* other accounts' code). *)

Inductive misc_inst : Type := 
  | STOP: misc_inst  (* finishing the execution normally, with the empty return data *)
  | CREATE: misc_inst  (* deploying some code in an account *)
  | CALL: misc_inst  (* calling (i.e. sending a message to) an account *)
  | CALLCODE: misc_inst  (* calling into this account, but the executed code can be some other account's *)
  | DELEGATECALL: misc_inst  (* calling into this account, the executed code can be some other account's
                       but the sent value and the sent data are unchanged. *)
  | RETURN: misc_inst  (* finishing the execution normally with data *)
  | SUICIDE: misc_inst .
Definition misc_inst_default: misc_inst  := STOP.
(* [?]: removed value specification. *)

Definition misc_inst_code  (inst1 : misc_inst )  : word8 :=  match ( inst1) with 
| STOP =>word8FromNumeral 0
| CREATE =>word8FromNumeral 240
| CALL =>word8FromNumeral 241
| CALLCODE =>word8FromNumeral 242
| RETURN =>word8FromNumeral 243
| DELEGATECALL =>word8FromNumeral 244
| SUICIDE =>word8FromNumeral 255
end.
(* [?]: removed value specification. *)

Definition misc_inst_numbers  (inst1 : misc_inst )  : (Z *Z ) % type:=  match ( inst1) with 
| STOP         => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 0))))
| CREATE       => ((Zpred (Zpos (P_of_succ_nat 3))),(Zpred (Zpos (P_of_succ_nat 1))))
| CALL         => ((Zpred (Zpos (P_of_succ_nat 7))),(Zpred (Zpos (P_of_succ_nat 1))))
| CALLCODE     => ((Zpred (Zpos (P_of_succ_nat 7))),(Zpred (Zpos (P_of_succ_nat 1))))
| RETURN       => ((Zpred (Zpos (P_of_succ_nat 2))),(Zpred (Zpos (P_of_succ_nat 0))))
| DELEGATECALL => ((Zpred (Zpos (P_of_succ_nat 6))),(Zpred (Zpos (P_of_succ_nat 1))))
| SUICIDE      => ((Zpred (Zpos (P_of_succ_nat 1))),(Zpred (Zpos (P_of_succ_nat 0))))
end.

Inductive inst : Type := 
  | Unknown:  byte  -> inst 
  | Bits:  bits_inst  -> inst 
  | Sarith:  sarith_inst  -> inst 
  | Arith:  arith_inst  -> inst 
  | Info:  info_inst  -> inst 
  | Dup:  dup_inst  -> inst 
  | Memory:  memory_inst  -> inst 
  | Storage:  storage_inst  -> inst 
  | Pc:  pc_inst  -> inst 
  | Stack:  stack_inst  -> inst 
  | Swap:  swap_inst  -> inst 
  | Log:  log_inst  -> inst 
  | Misc:  misc_inst  -> inst .
Definition inst_default: inst  := Unknown byte_default.

(* subsection {* Annotation  *} *)

Definition annotation : Type :=  aenv  ->  bool .
Definition annotation_default: annotation  := (fun (x117 :  aenv ) => bool_default).

(* subsection {* The Whole Instruction Set *} *)

(* The small inductive sets above are here combined into a single type. *)

Definition maybe_to_list {a : Type}  (m : option a )  : list a:=  match ( m) with 
 | None => []
 | Some s => [s]
end.
(* [?]: removed value specification. *)

Definition inst_code  (inst1 : inst )  : list (word8 ):=  match ( inst1) with 
| Unknown byte2 => [byte2]
| Bits b => [bits_inst_code b]
| Sarith s => [sarith_inst_code s]
| Arith a => [arith_inst_code a]
| Info i => [info_inst_code i]
| Dup d => [dup_inst_code d]
| Memory m => [memory_inst_code m]
| Storage s => [storage_inst_code s]
| Pc p => [pc_inst_code p]
| Stack s => stack_inst_code s
| Swap s => [swap_inst_code s]
| Log l => [log_inst_code l]
| Misc m => [misc_inst_code m]
end.
(* [?]: removed value specification. *)

Definition inst_stack_numbers  (i : inst )  : (Z *Z ) % type:=  match ( i) with 
| Unknown _ => ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 0))))
| Bits b => bits_stack_nums b
| Sarith s => sarith_inst_nums s
| Arith a => arith_inst_numbers a
| Info i' => info_inst_numbers i'
| Dup d => dup_inst_numbers d
| Memory m => memory_inst_numbers m
| Storage s => storage_inst_numbers s
| Pc p => pc_inst_numbers p
| Stack s => stack_inst_numbers s
| Swap s => swap_inst_numbers s
| Log l => log_inst_numbers l
| Misc m => misc_inst_numbers m
end.
(* [?]: removed value specification. *)

Definition inst_size  (i : inst )  : Z :=  (Zpred (Zpos (P_of_succ_nat (List.length (inst_code i))))).
(* [?]: removed value specification. *)

Definition Gzero   : Z := (Zpred (Zpos (P_of_succ_nat 0))).
(* [?]: removed value specification. *)

Definition Gbase   : Z := (Zpred (Zpos (P_of_succ_nat 2))).
(* [?]: removed value specification. *)

Definition Gverylow   : Z := (Zpred (Zpos (P_of_succ_nat 3))).
(* [?]: removed value specification. *)

Definition Glow   : Z := (Zpred (Zpos (P_of_succ_nat 5))).
(* [?]: removed value specification. *)

Definition Gmid   : Z := (Zpred (Zpos (P_of_succ_nat 8))).
(* [?]: removed value specification. *)

Definition Ghigh   : Z := (Zpred (Zpos (P_of_succ_nat 10))).
(* [?]: removed value specification. *)

(* [?]: removed top-level value definition. *)
(* [?]: removed value specification. *)

Definition Gextcode  (blocknumber : nat )  : Z := 
  if nat_gteb blocknumber (Coq.Init.Peano.mult( 2463)( 1000)) then(Zpred (Zpos (P_of_succ_nat 700))) else(Zpred (Zpos (P_of_succ_nat 20))).
(* [?]: removed value specification. *)

Definition Gbalance  (blocknumber : nat )  : Z := 
  if nat_gteb blocknumber (Coq.Init.Peano.mult( 2463)( 1000)) then(Zpred (Zpos (P_of_succ_nat 400))) else(Zpred (Zpos (P_of_succ_nat 20))).
(* [?]: removed value specification. *)

Definition Gsload  (blocknumber : nat )  : Z := 
  if nat_gteb blocknumber (Coq.Init.Peano.mult( 2463)( 1000)) then(Zpred (Zpos (P_of_succ_nat 200))) else(Zpred (Zpos (P_of_succ_nat 50))).
(* [?]: removed value specification. *)

Definition Gjumpdest   : Z := (Zpred (Zpos (P_of_succ_nat 1))).
(* [?]: removed value specification. *)

Definition Gsset   : Z := (Zpred (Zpos (P_of_succ_nat 20000))).
(* [?]: removed value specification. *)

Definition Gsreset   : Z := (Zpred (Zpos (P_of_succ_nat 5000))).
(* [?]: removed value specification. *)

Definition Rsclear   : Z := (Zpred (Zpos (P_of_succ_nat 15000))).
(* [?]: removed value specification. *)

Definition Rsuicide   : Z := (Zpred (Zpos (P_of_succ_nat 24000))).
(* [?]: removed value specification. *)

Definition Gsuicide  (blocknumber : nat )  : Z := 
  if nat_gteb blocknumber (Coq.Init.Peano.mult( 2463)( 1000)) then(Zpred (Zpos (P_of_succ_nat 5000))) else(Zpred (Zpos (P_of_succ_nat 0))).
(* [?]: removed value specification. *)

Definition Gcreate   : Z := (Zpred (Zpos (P_of_succ_nat 32000))).
(* [?]: removed value specification. *)

Definition Gcodedeposit   : Z := (Zpred (Zpos (P_of_succ_nat 200))).
(* [?]: removed value specification. *)

Definition Gcall  (blocknumber : nat )  : Z := 
  if nat_gteb blocknumber (Coq.Init.Peano.mult( 2463)( 1000)) then(Zpred (Zpos (P_of_succ_nat 700))) else(Zpred (Zpos (P_of_succ_nat 40))).
(* [?]: removed value specification. *)

Definition Gcallvalue   : Z := (Zpred (Zpos (P_of_succ_nat 9000))).
(* [?]: removed value specification. *)

Definition Gcallstipend   : Z := (Zpred (Zpos (P_of_succ_nat 2300))).
(* [?]: removed value specification. *)

Definition Gnewaccount   : Z := (Zpred (Zpos (P_of_succ_nat 25000))).
(* [?]: removed value specification. *)

Definition Gexp   : Z := (Zpred (Zpos (P_of_succ_nat 10))).
(* [?]: removed value specification. *)

Definition Gexpbyte   : Z := (Zpred (Zpos (P_of_succ_nat 50))).
(* [?]: removed value specification. *)

Definition Gmemory   : Z := (Zpred (Zpos (P_of_succ_nat 3))).
(* [?]: removed value specification. *)

Definition Gtxcreate   : Z := (Zpred (Zpos (P_of_succ_nat 32000))).
(* [?]: removed value specification. *)

Definition Gtxdatazero   : Z := (Zpred (Zpos (P_of_succ_nat 4))).
(* [?]: removed value specification. *)

Definition Gtxdatanonzero   : Z := (Zpred (Zpos (P_of_succ_nat 68))).
(* [?]: removed value specification. *)

Definition Gtransaction   : Z := (Zpred (Zpos (P_of_succ_nat 21000))).
(* [?]: removed value specification. *)

Definition Glog   : Z := (Zpred (Zpos (P_of_succ_nat 375))).
(* [?]: removed value specification. *)

Definition Glogdata   : Z := (Zpred (Zpos (P_of_succ_nat 8))).
(* [?]: removed value specification. *)

Definition Glogtopic   : Z := (Zpred (Zpos (P_of_succ_nat 375))).
(* [?]: removed value specification. *)

Definition Gsha3   : Z := (Zpred (Zpos (P_of_succ_nat 30))).
(* [?]: removed value specification. *)

Definition Gsha3word   : Z := (Zpred (Zpos (P_of_succ_nat 6))).
(* [?]: removed value specification. *)

Definition Gcopy   : Z := (Zpred (Zpos (P_of_succ_nat 3))).
(* [?]: removed value specification. *)

Definition Gblockhash   : Z := (Zpred (Zpos (P_of_succ_nat 20))).


(* section "A Contract Centric View of the EVM" *)

(* subsection "The Interaction between the Contract and the Environment" *)

(* In this development, the EVM execution is seen as an interaction between a single contract *)
(* and the environment.  The environment can call into the contract.  The contract can reply by just *)
(* finishing or failing, but it can also call an account\footnote{This might be the same account as our *)
(* invocation, but still the deeper calls is part of the world.}.  When our contract execution calls an account, *)
(* this is seen as an action towards the environment, because the environment then has to decide the *)
(* result of this call.  The environment can say that the call finished successfully or exceptionally. *)
(* The environment can also say that the call resulted in a reentrancy.  In other words, *)
(* the environment can call the contract again and change the storage and the balance of our contract. *)
(* The whole process is captured as a game between the environment and the contract. *)

(* subsubsection "The Environment's Moves" *)

(* The environment can call into our contract. *)
(* Then the environment provides our\footnote{ *)
(* The contract's behavior is controlled by a concrete code, but the environment's behavior is unrestricted.*)
(* So when I get emotional I call the contract ``our'' contract. *)
(* } contract *)
(* with the following information. *)

Record call_env : Type := {
  callenv_gaslimit : w256 ; (* the current block's gas limit *)
  callenv_value : w256 ; (* the amount of Eth sent along*)
  callenv_data : list  byte ; (* the data sent along *)
  callenv_caller : address ; (* the caller's address *)
  callenv_timestamp : w256 ; (* the timestamp of the current block *)
  callenv_blocknum : w256 ; (* the block number of the current block *)
  callenv_balance : address  ->  w256  (* the balances of all accounts. *)
}.
Notation "{[ r 'with' 'callenv_gaslimit' := e ]}" := ({| callenv_gaslimit := e; callenv_value := callenv_value r; callenv_data := callenv_data r; callenv_caller := callenv_caller r; callenv_timestamp := callenv_timestamp r; callenv_blocknum := callenv_blocknum r; callenv_balance := callenv_balance r |}).
Notation "{[ r 'with' 'callenv_value' := e ]}" := ({| callenv_value := e; callenv_gaslimit := callenv_gaslimit r; callenv_data := callenv_data r; callenv_caller := callenv_caller r; callenv_timestamp := callenv_timestamp r; callenv_blocknum := callenv_blocknum r; callenv_balance := callenv_balance r |}).
Notation "{[ r 'with' 'callenv_data' := e ]}" := ({| callenv_data := e; callenv_gaslimit := callenv_gaslimit r; callenv_value := callenv_value r; callenv_caller := callenv_caller r; callenv_timestamp := callenv_timestamp r; callenv_blocknum := callenv_blocknum r; callenv_balance := callenv_balance r |}).
Notation "{[ r 'with' 'callenv_caller' := e ]}" := ({| callenv_caller := e; callenv_gaslimit := callenv_gaslimit r; callenv_value := callenv_value r; callenv_data := callenv_data r; callenv_timestamp := callenv_timestamp r; callenv_blocknum := callenv_blocknum r; callenv_balance := callenv_balance r |}).
Notation "{[ r 'with' 'callenv_timestamp' := e ]}" := ({| callenv_timestamp := e; callenv_gaslimit := callenv_gaslimit r; callenv_value := callenv_value r; callenv_data := callenv_data r; callenv_caller := callenv_caller r; callenv_blocknum := callenv_blocknum r; callenv_balance := callenv_balance r |}).
Notation "{[ r 'with' 'callenv_blocknum' := e ]}" := ({| callenv_blocknum := e; callenv_gaslimit := callenv_gaslimit r; callenv_value := callenv_value r; callenv_data := callenv_data r; callenv_caller := callenv_caller r; callenv_timestamp := callenv_timestamp r; callenv_balance := callenv_balance r |}).
Notation "{[ r 'with' 'callenv_balance' := e ]}" := ({| callenv_balance := e; callenv_gaslimit := callenv_gaslimit r; callenv_value := callenv_value r; callenv_data := callenv_data r; callenv_caller := callenv_caller r; callenv_timestamp := callenv_timestamp r; callenv_blocknum := callenv_blocknum r |}).
Definition call_env_default: call_env  := {| callenv_gaslimit := w256_default; callenv_value := w256_default; callenv_data := DAEMON; callenv_caller := address_default; callenv_timestamp := w256_default; callenv_blocknum := w256_default; callenv_balance := (fun (x116 :  address ) => w256_default) |}.

(* After our contract calls accounts, the environment can make those accounts *)
(* return into our contracts.  The return value is not under control of our current *)
(* contract, so it is the environment's move.  In that case, the environment provides the *)
(* following information. *)

Record return_result : Type := {
  return_data : list  byte ; (* the returned data *)
  return_balance : address  ->  w256  (* the balance of all accounts at the moment of the return*)
}.
Notation "{[ r 'with' 'return_data' := e ]}" := ({| return_data := e; return_balance := return_balance r |}).
Notation "{[ r 'with' 'return_balance' := e ]}" := ({| return_balance := e; return_data := return_data r |}).
Definition return_result_default: return_result  := {| return_data := DAEMON; return_balance := (fun (x115 :  address ) => w256_default) |}.

(* Even our account's balance (and its storage) might have changed at this moment. *)
(* @{typ return_result} type is also used when our contract returns, as we will see. *)

(* With these definitions now we can define the environment's actions.  In addition to call and return, *)
(* there is another clause for failing back to the account.  This happens when our contract calls *)
(* an account but the called account fails. *)

(* When our contract deploys a smart contract, our contract should provide the following *)
(* information. *)

Inductive environment_action : Type := 
| EnvironmentCall:  call_env  -> environment_action  (* the environment calls into the account *)
| EnvironmentRet:  return_result  -> environment_action  (* the environment returns back to the account *)
| EnvironmentFail: environment_action .
Definition environment_action_default: environment_action  := EnvironmentCall call_env_default. (* the environment fails back to the account. *)


(* subsubsection "The Contract's Moves" *)

(* After being invoked, the contract can respond by calling an account, creating (or deploying)
a smart contract, destroying itself, returning, or failing.  When the contract calls an account,
the contract provides the following information.*)

(* When our contract deploys a smart contract, our contract should provide the following
information. *)

(* The contract's moves are summarized as follows. *)

Record call_arguments : Type := {
  callarg_gas : w256 ; (* The portion of the remaining gas that the callee is allowed to use *)
  callarg_code : address ; (* The code that executes during the call *)
  callarg_recipient : address ; (* The recipient of the call, whose balance and the storage are modified. *)
  callarg_value : w256 ; (* The amount of Eth sent along *)
  callarg_data : list  byte ; (* The data sent along *)
  callarg_output_begin : w256 ; (* The beginning of the memory region where the output data should be written. *)
  callarg_output_size : w256  (* The size of the memory regions where the output data should be written. *)
}.
Notation "{[ r 'with' 'callarg_gas' := e ]}" := ({| callarg_gas := e; callarg_code := callarg_code r; callarg_recipient := callarg_recipient r; callarg_value := callarg_value r; callarg_data := callarg_data r; callarg_output_begin := callarg_output_begin r; callarg_output_size := callarg_output_size r |}).
Notation "{[ r 'with' 'callarg_code' := e ]}" := ({| callarg_code := e; callarg_gas := callarg_gas r; callarg_recipient := callarg_recipient r; callarg_value := callarg_value r; callarg_data := callarg_data r; callarg_output_begin := callarg_output_begin r; callarg_output_size := callarg_output_size r |}).
Notation "{[ r 'with' 'callarg_recipient' := e ]}" := ({| callarg_recipient := e; callarg_gas := callarg_gas r; callarg_code := callarg_code r; callarg_value := callarg_value r; callarg_data := callarg_data r; callarg_output_begin := callarg_output_begin r; callarg_output_size := callarg_output_size r |}).
Notation "{[ r 'with' 'callarg_value' := e ]}" := ({| callarg_value := e; callarg_gas := callarg_gas r; callarg_code := callarg_code r; callarg_recipient := callarg_recipient r; callarg_data := callarg_data r; callarg_output_begin := callarg_output_begin r; callarg_output_size := callarg_output_size r |}).
Notation "{[ r 'with' 'callarg_data' := e ]}" := ({| callarg_data := e; callarg_gas := callarg_gas r; callarg_code := callarg_code r; callarg_recipient := callarg_recipient r; callarg_value := callarg_value r; callarg_output_begin := callarg_output_begin r; callarg_output_size := callarg_output_size r |}).
Notation "{[ r 'with' 'callarg_output_begin' := e ]}" := ({| callarg_output_begin := e; callarg_gas := callarg_gas r; callarg_code := callarg_code r; callarg_recipient := callarg_recipient r; callarg_value := callarg_value r; callarg_data := callarg_data r; callarg_output_size := callarg_output_size r |}).
Notation "{[ r 'with' 'callarg_output_size' := e ]}" := ({| callarg_output_size := e; callarg_gas := callarg_gas r; callarg_code := callarg_code r; callarg_recipient := callarg_recipient r; callarg_value := callarg_value r; callarg_data := callarg_data r; callarg_output_begin := callarg_output_begin r |}).
Definition call_arguments_default: call_arguments  := {| callarg_gas := w256_default; callarg_code := address_default; callarg_recipient := address_default; callarg_value := w256_default; callarg_data := DAEMON; callarg_output_begin := w256_default; callarg_output_size := w256_default |}.

Record create_arguments : Type := {
  createarg_value : w256 ; (* The value sent to the account *)
  createarg_code : list  byte  (* The code that deploys the runtime code. *)
}.
Notation "{[ r 'with' 'createarg_value' := e ]}" := ({| createarg_value := e; createarg_code := createarg_code r |}).
Notation "{[ r 'with' 'createarg_code' := e ]}" := ({| createarg_code := e; createarg_value := createarg_value r |}).
Definition create_arguments_default: create_arguments  := {| createarg_value := w256_default; createarg_code := DAEMON |}.

Inductive failure_reason : Type := 
| OutOfGas: failure_reason 
| TooLongStack: failure_reason 
| TooShortStack: failure_reason 
| InvalidJumpDestination: failure_reason 
| ShouldNotHappen: failure_reason .
Definition failure_reason_default: failure_reason  := OutOfGas.

Inductive contract_action : Type := 
| ContractCall:  call_arguments  -> contract_action  (* calling an account *)
| ContractDelegateCall:  call_arguments  -> contract_action  (* calling some code to run on behalf of the contract *)
| ContractCreate:  create_arguments  -> contract_action  (* deploying a smart contract *)
| ContractFail:  list  failure_reason  -> contract_action  (* failing back to the caller *)
| ContractSuicide: contract_action  (* destroying itself and returning back to the caller *)
| ContractReturn:  list  byte  -> contract_action .
Definition contract_action_default: contract_action  := ContractCall call_arguments_default. (* normally returning back to the caller *)

(* subsection "Program Representation" *)

(* For performance reasons, the instructions can be stored in a binary tree that allows *)
(* looking up instructions from the program counters. *)

Record program : Type := {
  program_content : Z  ->  option  inst  ; (* a way to look up instructions from positions *)
  program_length  : Z ; (* the length of the program in bytes *)
  program_annotation : Z  ->  list  annotation  (* a mapping from positions to annotations *)
}.
Notation "{[ r 'with' 'program_content' := e ]}" := ({| program_content := e; program_length := program_length r; program_annotation := program_annotation r |}).
Notation "{[ r 'with' 'program_length' := e ]}" := ({| program_length := e; program_content := program_content r; program_annotation := program_annotation r |}).
Notation "{[ r 'with' 'program_annotation' := e ]}" := ({| program_annotation := e; program_content := program_content r; program_length := program_length r |}).
Definition program_default: program  := {| program_content := (fun (x113 :  Z ) => DAEMON); program_length := Z_default; program_annotation := (fun (x114 :  Z ) => DAEMON) |}.
(* [?]: removed value specification. *)

Definition empty_program   : program :=  {|program_content := (fun  _ : Z  => None);program_length :=((Zpred (Zpos (P_of_succ_nat 0))));program_annotation := (fun  _ : Z  => [])
|}.
(* [?]: removed value specification. *)

Definition prepend_annotation  (pos : Z ) (annot : aenv  -> bool ) (orig : Z  -> list (aenv  -> bool )) (p : Z )  : list (aenv  -> bool ):=  if Z.eqb pos p then annot :: orig p else orig p.
(* [?]: removed value specification. *)

Program Fixpoint program_annotation_of_lst  (pos : Z ) (lst : list (inst ))  : Z  -> list (aenv  -> bool ):=  match ( lst) with 
| [] => (fun  _ : Z  => [])
| i :: rest => program_annotation_of_lst ( Coq.ZArith.BinInt.Zplus pos (inst_size i)) rest
end.
(* [?]: removed value specification. *)

Definition program_of_lst  (lst : list (inst )) (program_content_formatter : list (inst ) -> Z  -> option (inst ) )  : program :=  {|program_content := (program_content_formatter lst);program_length := ((Zpred (Zpos (P_of_succ_nat (List.length lst)))));program_annotation := (program_annotation_of_lst((Zpred (Zpos (P_of_succ_nat 0)))) lst)
|}.
(* [?]: removed value specification. *)

Definition program_as_natural_map  (p : program ) (idx : nat )  : word8 := 
   match ((program_content p) ((Zpred (Zpos (P_of_succ_nat idx))))) with 
   | None =>word8FromNumeral 0
   | Some inst1 =>
      match ( lem_list.index (inst_code inst1)( 0)) with 
      | None =>word8FromNumeral 0
      | Some a => a
      end
   end.

(* Execution Environments *)

(* I model an instruction as a function that takes environments and modifies some parts of them. *)

(* The execution of an EVM program happens in a block, and the following information about *)
(* the block should be available. *)

Record block_info : Type := {
  block_blockhash : w256  ->  w256 ; (* this captures the whole BLOCKHASH operation *)
  block_coinbase : address ; (* the miner who validates the block *)
  block_timestamp : w256 ;
  block_number : w256 ; (* the blocknumber of the block *)
  block_difficulty : w256 ;
  block_gaslimit : w256 ; (* the block gas imit *)
  block_gasprice : w256 
}.
Notation "{[ r 'with' 'block_blockhash' := e ]}" := ({| block_blockhash := e; block_coinbase := block_coinbase r; block_timestamp := block_timestamp r; block_number := block_number r; block_difficulty := block_difficulty r; block_gaslimit := block_gaslimit r; block_gasprice := block_gasprice r |}).
Notation "{[ r 'with' 'block_coinbase' := e ]}" := ({| block_coinbase := e; block_blockhash := block_blockhash r; block_timestamp := block_timestamp r; block_number := block_number r; block_difficulty := block_difficulty r; block_gaslimit := block_gaslimit r; block_gasprice := block_gasprice r |}).
Notation "{[ r 'with' 'block_timestamp' := e ]}" := ({| block_timestamp := e; block_blockhash := block_blockhash r; block_coinbase := block_coinbase r; block_number := block_number r; block_difficulty := block_difficulty r; block_gaslimit := block_gaslimit r; block_gasprice := block_gasprice r |}).
Notation "{[ r 'with' 'block_number' := e ]}" := ({| block_number := e; block_blockhash := block_blockhash r; block_coinbase := block_coinbase r; block_timestamp := block_timestamp r; block_difficulty := block_difficulty r; block_gaslimit := block_gaslimit r; block_gasprice := block_gasprice r |}).
Notation "{[ r 'with' 'block_difficulty' := e ]}" := ({| block_difficulty := e; block_blockhash := block_blockhash r; block_coinbase := block_coinbase r; block_timestamp := block_timestamp r; block_number := block_number r; block_gaslimit := block_gaslimit r; block_gasprice := block_gasprice r |}).
Notation "{[ r 'with' 'block_gaslimit' := e ]}" := ({| block_gaslimit := e; block_blockhash := block_blockhash r; block_coinbase := block_coinbase r; block_timestamp := block_timestamp r; block_number := block_number r; block_difficulty := block_difficulty r; block_gasprice := block_gasprice r |}).
Notation "{[ r 'with' 'block_gasprice' := e ]}" := ({| block_gasprice := e; block_blockhash := block_blockhash r; block_coinbase := block_coinbase r; block_timestamp := block_timestamp r; block_number := block_number r; block_difficulty := block_difficulty r; block_gaslimit := block_gaslimit r |}).
Definition block_info_default: block_info  := {| block_blockhash := (fun (x112 :  w256 ) => w256_default); block_coinbase := address_default; block_timestamp := w256_default; block_number := w256_default; block_difficulty := w256_default; block_gaslimit := w256_default; block_gasprice := w256_default |}.


(* A log entry is something like this. *)
Record log_entry : Type := {
  log_addr   : address ;
  log_topics : list  w256 ;
  log_data   : list  byte 
}.
Notation "{[ r 'with' 'log_addr' := e ]}" := ({| log_addr := e; log_topics := log_topics r; log_data := log_data r |}).
Notation "{[ r 'with' 'log_topics' := e ]}" := ({| log_topics := e; log_addr := log_addr r; log_data := log_data r |}).
Notation "{[ r 'with' 'log_data' := e ]}" := ({| log_data := e; log_addr := log_addr r; log_topics := log_topics r |}).
Definition log_entry_default: log_entry  := {| log_addr := address_default; log_topics := DAEMON; log_data := DAEMON |}.


(* The variable context contains information that is relatively volatile. *)

Record variable_ctx : Type := {
  vctx_stack : list  w256 ;
  vctx_memory : memory ;
  vctx_memory_usage : Z ; (* the current memory usage *)
  vctx_storage : storage ;
  vctx_pc : Z ; (* the program counter *)
  vctx_balance : address  ->  w256 ; (* balances of all accounts *)
  vctx_caller : address ; (* the caller's address *)
  vctx_value_sent : w256 ; (* the amount of Eth sent along the current invocation *)
  vctx_data_sent : list  byte ; (* the data sent along the current invocation *)
  vctx_storage_at_call : storage ; (* the storage content at the invocation*)
  vctx_balance_at_call : address  ->  w256 ; (* the balances at the invocation *)
  vctx_origin : address ; (* the external account that started the current transaction *)
  vctx_ext_program : address  ->  program ; (* the codes of all accounts *)
  vctx_block : block_info ; (* the current block *)
  vctx_gas : Z ; (* remaining gas before the instruction *)
  vctx_account_existence : address  ->  bool ;
  vctx_touched_storage_index : list  w256 ;
  vctx_logs : list  log_entry  (* stored newest first *)
}.
Notation "{[ r 'with' 'vctx_stack' := e ]}" := ({| vctx_stack := e; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_memory' := e ]}" := ({| vctx_memory := e; vctx_stack := vctx_stack r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_memory_usage' := e ]}" := ({| vctx_memory_usage := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_storage' := e ]}" := ({| vctx_storage := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_pc' := e ]}" := ({| vctx_pc := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_balance' := e ]}" := ({| vctx_balance := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_caller' := e ]}" := ({| vctx_caller := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_value_sent' := e ]}" := ({| vctx_value_sent := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_data_sent' := e ]}" := ({| vctx_data_sent := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_storage_at_call' := e ]}" := ({| vctx_storage_at_call := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_balance_at_call' := e ]}" := ({| vctx_balance_at_call := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_origin' := e ]}" := ({| vctx_origin := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_ext_program' := e ]}" := ({| vctx_ext_program := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_block' := e ]}" := ({| vctx_block := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_gas' := e ]}" := ({| vctx_gas := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_account_existence' := e ]}" := ({| vctx_account_existence := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_touched_storage_index := vctx_touched_storage_index r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_touched_storage_index' := e ]}" := ({| vctx_touched_storage_index := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_logs := vctx_logs r |}).
Notation "{[ r 'with' 'vctx_logs' := e ]}" := ({| vctx_logs := e; vctx_stack := vctx_stack r; vctx_memory := vctx_memory r; vctx_memory_usage := vctx_memory_usage r; vctx_storage := vctx_storage r; vctx_pc := vctx_pc r; vctx_balance := vctx_balance r; vctx_caller := vctx_caller r; vctx_value_sent := vctx_value_sent r; vctx_data_sent := vctx_data_sent r; vctx_storage_at_call := vctx_storage_at_call r; vctx_balance_at_call := vctx_balance_at_call r; vctx_origin := vctx_origin r; vctx_ext_program := vctx_ext_program r; vctx_block := vctx_block r; vctx_gas := vctx_gas r; vctx_account_existence := vctx_account_existence r; vctx_touched_storage_index := vctx_touched_storage_index r |}).
Definition variable_ctx_default: variable_ctx  := {| vctx_stack := DAEMON; vctx_memory := memory_default; vctx_memory_usage := Z_default; vctx_storage := storage_default; vctx_pc := Z_default; vctx_balance := (fun (x108 :  address ) => w256_default); vctx_caller := address_default; vctx_value_sent := w256_default; vctx_data_sent := DAEMON; vctx_storage_at_call := storage_default; vctx_balance_at_call := (fun (x109 :  address ) => w256_default); vctx_origin := address_default; vctx_ext_program := (fun (x110 :  address ) => program_default); vctx_block := block_info_default; vctx_gas := Z_default; vctx_account_existence := (fun (x111 :  address ) => bool_default); vctx_touched_storage_index := DAEMON; vctx_logs := DAEMON |}.

(* The constant context contains information that is rather stable. *)
Record constant_ctx : Type := {
  cctx_program : program ; (* the code in the account under verification. *)
  cctx_this : address  (* the address of the account under verification. *)
}.
Notation "{[ r 'with' 'cctx_program' := e ]}" := ({| cctx_program := e; cctx_this := cctx_this r |}).
Notation "{[ r 'with' 'cctx_this' := e ]}" := ({| cctx_this := e; cctx_program := cctx_program r |}).
Definition constant_ctx_default: constant_ctx  := {| cctx_program := program_default; cctx_this := address_default |}.

(* subsection {* The Result of an Instruction *} *)

(* The result of program execution is microscopically defined by results of instruction *)
(* executions.  The execution of a single instruction can result in the following cases: *)

Inductive instruction_result : Type := 
| InstructionContinue:  variable_ctx  -> instruction_result  (* the execution should continue. *)
| InstructionAnnotationFailure: instruction_result  (* the annotation turned out to be false. *)
| InstructionToEnvironment: 
  (* the execution has stopped; either for the moment just calling out another account, or *)
  (* finally finishing the current invocation *)
    contract_action    (* the contract's move *)
  ->  variable_ctx       (* the last venv *)
  ->  option  ((Z  * Z ) % type)  -> instruction_result .
Definition instruction_result_default: instruction_result  := InstructionContinue variable_ctx_default.
(* [?]: removed value specification. *)

Definition instruction_failure_result  (v : variable_ctx ) (reasons : list (failure_reason ))  : instruction_result := 
  InstructionToEnvironment (ContractFail reasons) v None.
(* [?]: removed value specification. *)

Definition instruction_return_result  (x : list (byte )) (v : variable_ctx )  : instruction_result := 
  InstructionToEnvironment (ContractReturn x) v None.
(* [?]: removed value specification. *)

Definition gas  (v : variable_ctx )  : word256 :=  word256FromInteger(vctx_gas v).
(* [?]: removed value specification. *)

Definition M  (s : Z ) (f : word256 ) (l : word256 )  : Z := 
  if classical_boolean_equivalence l(word256FromNumeral 0) then s else Zmax s ( Coq.ZArith.Zdiv.Zdiv( Coq.ZArith.BinInt.Zplus (Coq.ZArith.BinInt.Zplus(uint f) (uint l))((Zpred (Zpos (P_of_succ_nat 31)))))((Zpred (Zpos (P_of_succ_nat 32))))).
(* [?]: removed value specification. *)

Definition update_balance  (a : word160 ) (f : word256  -> word256 ) (orig : word160  -> word256 ) (x : word160 )  : word256 :=  if classical_boolean_equivalence x a then f (orig a) else orig x.
(* [?]: removed value specification. *)

Definition vctx_pop_stack  (n : nat ) (v : variable_ctx )  : variable_ctx := 
 {[ v with vctx_stack := drop n(vctx_stack v)  ]}.
(* [?]: removed value specification. *)

Definition vctx_update_storage  (idx : word256 ) (vall : word256 ) (v : variable_ctx )  : variable_ctx := 
  {[ v with vctx_storage := (fun (x : word256 ) => if classical_boolean_equivalence x idx then vall else(vctx_storage v) x)  ]}.
(* [?]: removed value specification. *)

Definition vctx_next_instruction  (v : variable_ctx ) (c : constant_ctx )  : option (inst ) := 
  match ((program_content(cctx_program c))(vctx_pc v)) with 
  | Some i => Some i
  | None => Some (Misc STOP)
  end.
(* [?]: removed value specification. *)

Definition vctx_advance_pc  (c : constant_ctx ) (v : variable_ctx )  : variable_ctx := 
  {[ v with vctx_pc :=
     (match ( vctx_next_instruction v c) with 
     | None => Coq.ZArith.BinInt.Zplus(vctx_pc v)((Zpred (Zpos (P_of_succ_nat 1))))
     | Some inst1 => Coq.ZArith.BinInt.Zplus(vctx_pc v) ( (inst_size inst1)) end)  ]}.
(* [?]: removed value specification. *)

Definition stack_0_0_op  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  InstructionContinue (vctx_advance_pc c v).
(* [?]: removed value specification. *)

Definition stack_0_1_op  (v : variable_ctx ) (c : constant_ctx ) (w : word256 )  : instruction_result := 
   InstructionContinue (vctx_advance_pc c {[ v with vctx_stack := w ::(vctx_stack v)  ]}).
(* [?]: removed value specification. *)

Definition stack_1_1_op  (v : variable_ctx ) (c : constant_ctx ) (f : word256  -> word256 )  : instruction_result :=  match ((vctx_stack v)) with 
  | [] => instruction_failure_result v [TooShortStack]
  | h :: t => InstructionContinue (vctx_advance_pc c {[ v with vctx_stack := f h :: t  ]})
end.
(* [?]: removed value specification. *)

Definition stack_2_1_op  (v : variable_ctx ) (c : constant_ctx ) (f : word256  -> word256  -> word256 )  : instruction_result :=  match ((vctx_stack v)) with 
 | operand0 :: operand1 :: rest =>
       InstructionContinue
         (vctx_advance_pc c {[ v with vctx_stack := f operand0 operand1 :: rest  ]})
  | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition stack_3_1_op  (v : variable_ctx ) (c : constant_ctx ) (f : word256  -> word256  -> word256  -> word256 )  : instruction_result :=  match ((vctx_stack v)) with 
 | operand0 :: operand1 :: operand2 :: rest =>
       InstructionContinue
         (vctx_advance_pc c {[ v with vctx_stack := f operand0 operand1 operand2 :: rest  ]})
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition sstore  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | addr :: vl :: stack_tail =>
      InstructionContinue (vctx_advance_pc c
        (vctx_update_storage addr vl  
  {[
  {[ v with vctx_touched_storage_index := addr ::
                                          (vctx_touched_storage_index v)  ]} with vctx_stack := stack_tail  ]}))
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition build_aenv  (v : variable_ctx ) (c : constant_ctx )  : aenv :=  {|aenv_stack :=(vctx_stack v);aenv_memory :=(vctx_memory v);aenv_storage :=(vctx_storage v);aenv_balance :=(vctx_balance v);aenv_caller :=(vctx_caller v);aenv_value_sent :=(vctx_value_sent v);aenv_data_sent :=(vctx_data_sent v);aenv_storage_at_call :=(vctx_storage_at_call v);aenv_balance_at_call :=(vctx_balance_at_call v);aenv_this :=(cctx_this c);aenv_origin :=(vctx_origin v)
|}.
(* [?]: removed value specification. *)

Definition jump  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | [] => instruction_failure_result v [TooShortStack]
 | pos :: tl =>
     let v_new := {[ {[ v with vctx_pc := uint pos  ]} with vctx_stack := tl  ]} in
     match ( vctx_next_instruction v_new c) with 
      | Some( Pc JUMPDEST) => InstructionContinue v_new
      | _ => instruction_failure_result v [InvalidJumpDestination]
     end
end.
(* [?]: removed value specification. *)

Definition blockedInstructionContinue  (v : variable_ctx ) (bloop : bool )  : instruction_result :=  InstructionContinue v.
(* [?]: removed value specification. *)

Definition blocked_jump  (v : variable_ctx ) (c : constant_ctx ) (bloop : bool )  : instruction_result :=  jump v c.
(* [?]: removed value specification. *)

Definition strict_if {a : Type}  (b : bool ) (x : bool  -> a) (y : bool  -> a)  : a:=  if b then x true else y true.
(* [?]: removed value specification. *)

Definition jumpi  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | pos :: cond :: rest =>
    let new_env := {[ v with vctx_stack := pos :: rest  ]} in
    strict_if ( classical_boolean_equivalence cond(word256FromNumeral 0))
           (blockedInstructionContinue (vctx_advance_pc c (vctx_pop_stack( 2) v)))
           (blocked_jump new_env c)
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition datasize  (v : variable_ctx )  : word256 :=  word256FromNat (List.length(vctx_data_sent v)).
(* [?]: removed value specification. *)

Definition byte_list_fill_right  (filled : word8 ) (target : nat ) (orig : list (word8 ))  : list (word8 ):= 
  if nat_gteb (List.length orig) target then orig else
  let filling_len := Coq.Init.Peano.minus target (List.length orig) in
  (@ List.app _) orig (replicate filling_len filled).
(* [?]: removed value specification. *)

Definition constant_mark  (lst : list (byte ))  : list (byte ):=  lst.
(* [?]: removed value specification. *)

Definition read_word_from_bytes  (idx : nat ) (lst : list (word8 ))  : word256 := 
  if nat_lteb ( (List.length lst)) idx then (word256FromNumeral 0)
  else
    word_of_bytes
    (byte_list_fill_right(word8FromNumeral 0)( 32)
        (take( 32) (drop ( idx) lst))).
(* [?]: removed value specification. *)

Definition cut_data  (v : variable_ctx ) (idx : word256 )  : word256 :=  read_word_from_bytes (word256ToNatural idx)(vctx_data_sent v).
(* [?]: removed value specification. *)

Program Fixpoint cut_natural_map  (idx : nat ) (n : nat ) (nmap : nat  -> word8 )  : list (word8 ):=  match ( n) with 
 | 0 => []
 | S (n) => nmap idx :: cut_natural_map ( Coq.Init.Peano.plus idx( 1)) n nmap
end.
(* [?]: removed value specification. *)

Definition call  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | e0 :: e1 :: e2 :: e3 :: e4 :: e5 :: e6 :: rest =>
     strict_if (word256ULT ((ii(vctx_balance v))(cctx_this c)) e2)
        (fun  _ : bool  => (InstructionContinue
           (vctx_advance_pc c
             {[ v with vctx_stack := (word256FromNumeral 0 :: rest)
              ]}
           )))
       (fun  _ : bool  => InstructionToEnvironment (ContractCall
         {|callarg_gas := e0;callarg_code := (w256_to_address e1);callarg_recipient := (w256_to_address e1);callarg_value := e2;callarg_data := (cut_memory e3 e4(vctx_memory v));callarg_output_begin := e5;callarg_output_size := e6 |})
        ( {[ {[{[ (vctx_advance_pc c v) with vctx_memory_usage := M (M(vctx_memory_usage v) e3 e4) e5 e6  ]} with vctx_balance := update_balance(cctx_this c) (fun (orig : word256 ) => word256Minus orig e2)(vctx_balance v)  ]} with vctx_stack := rest  ]})
        (Some (* saving the variable environment for timing *)
           (uint e5, uint e6)))
  | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition delegatecall  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | e0 :: e1 :: e3 :: e4 :: e5 :: e6 :: rest =>
    if word256ULT (ii(vctx_balance v)(cctx_this c))(vctx_value_sent v) then
        (InstructionContinue
           (vctx_advance_pc c
             {[ v with vctx_stack := (word256FromNumeral 0 :: rest)
              ]}
           ))
     else
       InstructionToEnvironment
         (ContractDelegateCall
           {|callarg_gas := e0;callarg_code := (w256_to_address e1);callarg_recipient := (w256_to_address e1);callarg_value :=(vctx_value_sent v);callarg_data := (cut_memory e3 e4(vctx_memory v));callarg_output_begin := e5;callarg_output_size := e6 |})
          ( {[{[ (vctx_advance_pc c v) with vctx_memory_usage := M (M(vctx_memory_usage v) e3 e4) e5 e6  ]} with vctx_stack := rest  ]})
          (Some (* save the variable environment for returns *)
            (uint e5, uint e6))
  | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition callcode  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | e0 :: e1 :: e2 :: e3 :: e4 :: e5 :: e6 :: rest =>
    if word256ULT (ii(vctx_balance v)(cctx_this  c)) e2 then
        (InstructionContinue
           (vctx_advance_pc c
             {[ v with vctx_stack := (word256FromNumeral 0 :: rest)
              ]}
           ))
     else
       InstructionToEnvironment
         (ContractDelegateCall
           {|callarg_gas := e0;callarg_code := (w256_to_address e1);callarg_recipient :=(cctx_this c);callarg_value := e2;callarg_data := (cut_memory e3 e4(vctx_memory v));callarg_output_begin := e5;callarg_output_size := e6 |})
          ( {[ {[{[ (vctx_advance_pc c v) with vctx_balance := update_balance(cctx_this c) (fun (orig : word256 ) => word256Minus orig e2)(vctx_balance v)  ]} with vctx_memory_usage := M (M(vctx_memory_usage v) e3 e4) e5 e6  ]} with vctx_stack := rest  ]})
          (Some (* saving the variable environment *) (uint e5, uint e6))
  | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition create  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
  | vl :: code_start :: code_len :: rest =>
      if word256ULT (ii(vctx_balance v)(cctx_this c)) vl then
        (InstructionContinue
           (vctx_advance_pc c
             {[ v with vctx_stack := (word256FromNumeral 0 :: rest)
              ]}
           ))
      else
        let code := cut_memory code_start code_len(vctx_memory v) in
        let new_balance := update_balance(cctx_this c) (fun (orig : word256 ) => word256Minus orig vl)(vctx_balance v) in
        InstructionToEnvironment
           (ContractCreate
             {|createarg_value := vl;createarg_code := code |})
            ( {[ {[{[ (vctx_advance_pc c v) with vctx_memory_usage := M(vctx_memory_usage v) code_start code_len  ]} with vctx_balance := new_balance  ]} with vctx_stack := rest  ]})
            (Some (* when returning to this invocation, use the following variable environment *)
              ((Zpred (Zpos (P_of_succ_nat 0))),(Zpred (Zpos (P_of_succ_nat 0)))))
  | _ => instruction_failure_result v [TooShortStack]
end.

(* For implementing RETURN, I need to cut a region from the memory
according to the stack elements: *)

Definition vctx_returned_bytes  (v : variable_ctx )  : list (word8 ):=  match ((vctx_stack v)) with 
 | e0 :: e1 :: _ => cut_memory e0 e1(vctx_memory v)
 | _ => []
end.
(* [?]: removed value specification. *)

Definition ret  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=   match ((vctx_stack v)) with 
 | e0 :: e1 :: _ =>
     let new_v := {[ v with vctx_memory_usage := M(vctx_memory_usage v) e0 e1  ]} in
     InstructionToEnvironment (ContractReturn (vctx_returned_bytes new_v))
                           v
                           None (* No possibility of ever returning to this invocation. *)
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition stop  (v : variable_ctx ) (c : constant_ctx )  : instruction_result := 
    InstructionToEnvironment (ContractReturn []) v None.
(* [?]: removed value specification. *)

Definition pop  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | _ :: tl => InstructionContinue (vctx_advance_pc c {[ v with vctx_stack := tl  ]})
 | [] => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition general_dup  (n : word4 ) (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ( lem_list.index(vctx_stack v) (word4ToNat n)) with 
  | None => instruction_failure_result v [TooShortStack]
  | Some duplicated => InstructionContinue (vctx_advance_pc c {[ v with vctx_stack := duplicated ::(vctx_stack v)  ]})
end.
(* [?]: removed value specification. *)

Program Fixpoint store_byte_list_memory  (pos : word256 ) (lst : list (word8 )) (orig : word256  -> word8 )  : word256  -> word8 :=  match ( lst) with 
 | [] => orig
 | h :: t =>
     store_byte_list_memory ( word256Add pos(word256FromNumeral 1)) t (fun (p : word256 ) => if classical_boolean_equivalence pos p then h else orig p)
end.
(* [?]: removed value specification. *)

Definition store_word_memory  (pos : word256 ) (vl : word256 ) (mem : w256  -> byte )  : w256  -> byte := 
   store_byte_list_memory pos (word_rsplit256 vl) mem.
(* [?]: removed value specification. *)

Definition mstore  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
  | pos :: vl :: rest =>
       let new_memory := store_word_memory pos vl(vctx_memory v) in
       InstructionContinue (vctx_advance_pc c  
  {[ {[
  {[ v with vctx_memory_usage := M (vctx_memory_usage v) pos
                                   (word256FromNumeral 32)
   ]} with vctx_memory := new_memory  ]} with vctx_stack := rest  ]})
  | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition mload  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | pos :: rest =>
      let value1 := read_word_from_bytes( 0) (cut_memory pos(word256FromNumeral 32)(vctx_memory v)) in
      InstructionContinue
        (vctx_advance_pc c  
  {[ {[ v with vctx_memory_usage := M (vctx_memory_usage v) pos
                                      (word256FromNumeral 32)  ]} with vctx_stack := 
  value1 :: rest  ]})
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition mstore8  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | pos :: vl :: rest =>
   let new_memory := (fun (p : word256 ) => if classical_boolean_equivalence p pos then w256_to_byte vl else(vctx_memory v) p) in
   InstructionContinue (vctx_advance_pc c  
  {[ {[
  {[ v with vctx_memory := new_memory  ]} with vctx_memory_usage := M
                                                                    (vctx_memory_usage v)
                                                                    pos
                                                                    (
                                                                    word256FromNumeral
                                                                    8)  ]} with vctx_stack := rest  ]})
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition input_as_natural_map  (lst : list (word8 ))  (idx : nat )  : word8 := 
  let idx := (Zpred (Zpos (P_of_succ_nat idx))) in
  if int_gtb((Zpred (Zpos (P_of_succ_nat 0)))) idx then (word8FromNumeral 0)
  else if int_lteb ((Zpred (Zpos (P_of_succ_nat (List.length lst))))) idx then (word8FromNumeral 0)
  else
    match ( lem_list.index lst (Zabs_nat ( idx))) with 
    | None =>word8FromNumeral 0
    | Some a => a
    end.
(* [?]: removed value specification. *)

Definition calldatacopy  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | dst_start :: src_start :: len :: rest =>
       let data := cut_natural_map (word256ToNatural src_start) (word256ToNatural len) (input_as_natural_map(vctx_data_sent v)) in
       let new_memory := store_byte_list_memory dst_start data(vctx_memory v) in
       InstructionContinue (vctx_advance_pc c  
  {[ {[
  {[ v with vctx_memory_usage := M (vctx_memory_usage v) dst_start len  ]} with vctx_memory := new_memory  ]} with vctx_stack := rest  ]})
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition codecopy  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | dst_start :: src_start :: len :: rest =>
     let data := cut_natural_map (word256ToNatural src_start) (word256ToNatural len)
                  (program_as_natural_map(cctx_program c)) in
     let new_memory := store_byte_list_memory dst_start data(vctx_memory v) in
     InstructionContinue (vctx_advance_pc c  
  {[ {[
  {[ v with vctx_memory_usage := M (vctx_memory_usage v) dst_start len  ]} with vctx_memory := new_memory  ]} with vctx_stack := rest  ]})
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition extcodecopy  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | addr :: dst_start :: src_start :: len :: rest =>
     let data := cut_natural_map (word256ToNatural src_start) (word256ToNatural len)
                  (program_as_natural_map
                    (ii(vctx_ext_program v) (w256_to_address addr))) in
     let new_memory := store_byte_list_memory dst_start data(vctx_memory v) in
     InstructionContinue (vctx_advance_pc c  
  {[ {[
  {[ v with vctx_memory_usage := M (vctx_memory_usage v) dst_start len  ]} with vctx_memory := new_memory  ]} with vctx_stack := rest  ]})
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition pc  (v : variable_ctx ) (c : constant_ctx )  : instruction_result := 
   InstructionContinue (vctx_advance_pc c
     {[ v with vctx_stack := word256FromInteger(vctx_pc v) ::(vctx_stack v) ]}).
(* [?]: removed value specification. *)

Definition vctx_stack_default  (idx : Z ) (v : variable_ctx )  : word256 := 
  match ( lem_list.index(vctx_stack v) (Zabs_nat idx)) with 
  | Some w => w
  | None =>word256FromNumeral 0
  end.
(* [?]: removed value specification. *)

Definition create_log_entry  (n : nat ) (v : variable_ctx ) (c : constant_ctx )  : log_entry := 
  {|log_addr :=(cctx_this c)
   ;log_topics := (drop( 2) (take ( Coq.Init.Peano.plus n( 2))(vctx_stack v)))
   ;log_data := (vctx_returned_bytes v)
  |}.
(* [?]: removed value specification. *)

Definition log  (n : nat ) (v : variable_ctx ) (c : constant_ctx )  : instruction_result := 
   let new_log_entry := create_log_entry n v c in
   InstructionContinue
    (vctx_advance_pc c (vctx_pop_stack (Coq.Init.Peano.plus n( 2)) 
  {[ {[ v with vctx_logs := new_log_entry :: (vctx_logs v)
   ]} with vctx_memory_usage := M (vctx_memory_usage v)
                                  (vctx_stack_default
                                     ((Zpred (Zpos (P_of_succ_nat 0)))) 
                                   v)
                                  (vctx_stack_default
                                     ((Zpred (Zpos (P_of_succ_nat 1)))) 
                                   v)  ]})).
(* [?]: removed value specification. *)

Definition list_swap {a : Type}  (n : nat ) (lst : list a)  : option (list a) :=  match ( (index lst n, index lst( 0))) with 
 | (Some n_th,  Some first) => Some (lem_list.concat [[n_th]; take ( Coq.Init.Peano.minus n( 1)) (drop( 1) lst); [first]; drop ( Coq.Init.Peano.plus( 1) n) lst])
 | _ => None
end.
(* [?]: removed value specification. *)

Definition swap  (n : nat ) (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ( list_swap ( Coq.Init.Peano.plus n( 1))(vctx_stack v)) with 
 | None => instruction_failure_result v [TooShortStack]
 | Some new_stack => InstructionContinue (vctx_advance_pc c {[ v with vctx_stack := new_stack  ]})
end.
(* [?]: removed value specification. *)

Definition sha3  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | start :: len :: rest =>
      InstructionContinue (
        vctx_advance_pc c  
  {[
  {[ v with vctx_memory_usage := M (vctx_memory_usage v) start len  ]} with vctx_stack := 
  keccak (cut_memory start len (vctx_memory v)) :: rest  ]})
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition suicide  (v : variable_ctx ) (c : constant_ctx )  : instruction_result :=  match ((vctx_stack v)) with 
 | dst :: _ =>
     let new_balance := (fun (addr : word160 ) =>
        if classical_boolean_equivalence addr(cctx_this c) then (word256FromNumeral 0) else
        if classical_boolean_equivalence addr (w256_to_address dst) then word256Add (ii(vctx_balance v)(cctx_this c)) (ii(vctx_balance v) addr) else
        ii(vctx_balance v) addr) in
     InstructionToEnvironment ContractSuicide v None
 | _ => instruction_failure_result v [TooShortStack]
end.
(* [?]: removed value specification. *)

Definition Cmem  (a : Z )  : Z :=  Coq.ZArith.BinInt.Zplus (Coq.ZArith.BinInt.Zmult Gmemory a) ( Coq.ZArith.Zdiv.Zdiv (Coq.ZArith.BinInt.Zmult a a)((Zpred (Zpos (P_of_succ_nat 512))))).
(* [?]: removed value specification. *)

Definition Csstore  (orig : word256 ) (newer : word256 )  : Z :=  if negb ( classical_boolean_equivalence newer(word256FromNumeral 0)) && classical_boolean_equivalence orig(word256FromNumeral 0) then Gsset else Gsreset.
(* [?]: removed value specification. *)

Definition Csuicide  (recipient_empty : bool ) (blocknumber : nat )  : Z :=  Coq.ZArith.BinInt.Zplus  
(Gsuicide blocknumber) (if recipient_empty && nat_gteb blocknumber (Coq.Init.Peano.mult( 2463)( 1000)) then Gnewaccount else(Zpred (Zpos (P_of_succ_nat 0)))).
(* [?]: removed value specification. *)

Definition Cnew  (value1 : word256 ) (emp : bool )  : Z :=  if emp && negb ( classical_boolean_equivalence value1(word256FromNumeral 0)) then Gnewaccount else(Zpred (Zpos (P_of_succ_nat 0))).
(* [?]: removed value specification. *)

Definition Cxfer  (value1 : word256 )  : Z :=  if classical_boolean_equivalence value1(word256FromNumeral 0) then(Zpred (Zpos (P_of_succ_nat 0))) else Gcallvalue.
(* [?]: removed value specification. *)

Definition Cextra  (value1 : word256 ) (emp : bool ) (blocknumber : nat )  : Z :=  Coq.ZArith.BinInt.Zplus (Coq.ZArith.BinInt.Zplus (Gcall blocknumber) (Cxfer value1)) (Cnew value1 emp).
(* [?]: removed value specification. *)

Definition L  (x : Z )  : Z :=  Coq.ZArith.BinInt.Zminus x (Coq.ZArith.Zdiv.Zdiv x((Zpred (Zpos (P_of_succ_nat 64))))).
(* [?]: removed value specification. *)

Definition Cgascap  (mu0 : word256 ) (mu1 : word256 ) (emp : bool ) (remaining_gas : Z ) (blocknumber : nat )  : Z := 
  if int_gteb remaining_gas (Cextra mu1 emp blocknumber) then
    Zmin (L ( Coq.ZArith.BinInt.Zminus remaining_gas (Cextra mu1 emp blocknumber))) (uint mu0)
  else
    uint mu0.
(* [?]: removed value specification. *)

Definition Ccallgas  (mu0 : word256 ) (mu1 : word256 ) (mu2 : word256 ) (emp : bool ) (remaining_gas : Z ) (blocknumber : nat )  : Z := 
  if classical_boolean_equivalence mu2(word256FromNumeral 0) then
    Cgascap mu0 mu1 emp remaining_gas blocknumber
  else Coq.ZArith.BinInt.Zplus    
(Cgascap mu0 mu1 emp remaining_gas blocknumber) Gcallstipend.
(* [?]: removed value specification. *)

Definition Ccall  (mu0 : word256 ) (mu1 : word256 ) (mu2 : word256 ) (emp : bool ) (remaining_gas : Z ) (blocknumber : nat )  : Z :=  Coq.ZArith.BinInt.Zplus (Cgascap mu0 mu1 emp remaining_gas blocknumber) (Cextra mu2 emp blocknumber).
(* [?]: removed value specification. *)

Definition thirdComponentOfC  (i : inst ) (s0 : word256 ) (s1 : word256 ) (s2 : word256 ) (s3 : word256 ) (recipient_empty : bool ) (orig_val : word256 ) (new_val : word256 ) (remaining_gas : Z ) (blocknumber : nat )  : Z := 
  match ( i) with 
  | Storage SSTORE => Csstore orig_val new_val
  | Arith EXP => Coq.ZArith.BinInt.Zplus Gexp (if classical_boolean_equivalence s1(word256FromNumeral 0) then(Zpred (Zpos (P_of_succ_nat 0))) else Coq.ZArith.BinInt.Zmult Gexpbyte ( Coq.ZArith.BinInt.Zplus((Zpred (Zpos (P_of_succ_nat 1)))) (log256floor (uint s1))))
  | Memory CALLDATACOPY => Coq.ZArith.BinInt.Zplus Gverylow (Coq.ZArith.BinInt.Zmult Gcopy ( Coq.ZArith.Zdiv.Zdiv( Coq.ZArith.BinInt.Zplus(uint s2)((Zpred (Zpos (P_of_succ_nat 31)))))((Zpred (Zpos (P_of_succ_nat 32))))))
  | Memory CODECOPY => Coq.ZArith.BinInt.Zplus Gverylow (Coq.ZArith.BinInt.Zmult Gcopy ( Coq.ZArith.Zdiv.Zdiv( Coq.ZArith.BinInt.Zplus(uint s2)((Zpred (Zpos (P_of_succ_nat 31)))))((Zpred (Zpos (P_of_succ_nat 32))))))
  | Memory EXTCODECOPY => Coq.ZArith.BinInt.Zplus (Gextcode blocknumber) (Coq.ZArith.BinInt.Zmult Gcopy ( Coq.ZArith.Zdiv.Zdiv( Coq.ZArith.BinInt.Zplus(uint s3)((Zpred (Zpos (P_of_succ_nat 31)))))((Zpred (Zpos (P_of_succ_nat 32))))))
  | Log LOG0 => Coq.ZArith.BinInt.Zplus Glog (Coq.ZArith.BinInt.Zmult Glogdata (uint s1))
  | Log LOG1 => Coq.ZArith.BinInt.Zplus (Coq.ZArith.BinInt.Zplus Glog (Coq.ZArith.BinInt.Zmult Glogdata (uint s1))) Glogtopic
  | Log LOG2 => Coq.ZArith.BinInt.Zplus (Coq.ZArith.BinInt.Zplus Glog (Coq.ZArith.BinInt.Zmult Glogdata (uint s1))) (Coq.ZArith.BinInt.Zmult((Zpred (Zpos (P_of_succ_nat 2)))) Glogtopic)
  | Log LOG3 => Coq.ZArith.BinInt.Zplus (Coq.ZArith.BinInt.Zplus Glog (Coq.ZArith.BinInt.Zmult Glogdata (uint s1))) (Coq.ZArith.BinInt.Zmult((Zpred (Zpos (P_of_succ_nat 3)))) Glogtopic)
  | Log LOG4 => Coq.ZArith.BinInt.Zplus (Coq.ZArith.BinInt.Zplus Glog (Coq.ZArith.BinInt.Zmult Glogdata (uint s1))) (Coq.ZArith.BinInt.Zmult((Zpred (Zpos (P_of_succ_nat 4)))) Glogtopic)
  | Misc CALL
    => Ccall s0 s1 s2 recipient_empty remaining_gas blocknumber
  | Misc CALLCODE
    => Ccall s0 s1 s2 recipient_empty remaining_gas blocknumber
  | Misc DELEGATECALL
    => Ccall s0 s1(word256FromNumeral 0)  recipient_empty remaining_gas blocknumber
  | Misc SUICIDE => Csuicide recipient_empty blocknumber
  | Misc CREATE => Gcreate
  | Arith SHA3 => Coq.ZArith.BinInt.Zplus Gsha3 (Coq.ZArith.BinInt.Zmult Gsha3word ( Coq.ZArith.Zdiv.Zdiv( Coq.ZArith.BinInt.Zplus(uint s1)((Zpred (Zpos (P_of_succ_nat 31)))))((Zpred (Zpos (P_of_succ_nat 32))))))
  | Pc JUMPDEST => Gjumpdest
  | Storage SLOAD => Gsload blocknumber
  | Misc STOP => Gzero
  | Misc RETURN => Gzero
  | Info ADDRESS => Gbase
  | Info ORIGIN => Gbase
  | Info CALLER => Gbase
  | Info CALLVALUE => Gbase
  | Info CALLDATASIZE => Gbase
  | Info CODESIZE => Gbase
  | Info GASPRICE => Gbase
  | Info COINBASE => Gbase
  | Info TIMESTAMP => Gbase
  | Info NUMBER => Gbase
  | Info DIFFICULTY => Gbase
  | Info GASLIMIT => Gbase
  | Stack POP => Gbase
  | Pc PC => Gbase
  | Memory MSIZE => Gbase
  | Info GAS => Gbase
  | Arith ADD => Gverylow
  | Arith SUB => Gverylow
  | Bits inst_NOT => Gverylow
  | Arith inst_LT => Gverylow
  | Arith inst_GT => Gverylow
  | Sarith SLT => Gverylow
  | Sarith SGT => Gverylow
  | Arith inst_EQ => Gverylow
  | Arith ISZERO => Gverylow
  | Bits inst_AND => Gverylow
  | Bits inst_OR => Gverylow
  | Bits inst_XOR => Gverylow
  | Bits BYTE => Gverylow
  | Stack CALLDATALOAD => Gverylow
  | Memory MLOAD => Gverylow
  | Memory MSTORE => Gverylow
  | Memory MSTORE8 => Gverylow
  | Stack( PUSH_N _) => Gverylow
  | Dup _ => Gverylow
  | Swap _ => Gverylow
  | Arith MUL => Glow
  | Arith DIV => Glow
  | Sarith SDIV => Glow
  | Arith MOD => Glow
  | Sarith SMOD => Glow
  | Sarith SIGNEXTEND => Glow
  | Arith ADDMOD => Gmid
  | Arith MULMOD => Gmid
  | Pc JUMP => Gmid
  | Pc JUMPI => Ghigh
  | Info EXTCODESIZE => Gextcode blocknumber
  | Info BALANCE => Gbalance blocknumber
  | Info BLOCKHASH => Gblockhash
  | _ =>(Zpred (Zpos (P_of_succ_nat 0))) (* How is this case dealt in the yellow paper *)
  end.
(* [?]: removed value specification. *)

Definition C  (old_memory_consumption : Z ) (new_memory_consumption1 : Z ) (i : inst ) (s0 : word256 ) (s1 : word256 ) (s2 : word256 ) (s3 : word256 ) (recipient_empty : bool ) (orig : word256 ) (new_val : word256 ) (remaining_gas : Z ) (blocknumber : nat )  : Z :=  Coq.ZArith.BinInt.Zplus  (Coq.ZArith.BinInt.Zminus  
(Cmem new_memory_consumption1) (Cmem old_memory_consumption))  
(thirdComponentOfC i s0 s1 s2 s3 recipient_empty orig new_val remaining_gas blocknumber).
(* [?]: removed value specification. *)

Definition vctx_next_instruction_default  (v : variable_ctx ) (c : constant_ctx )  : inst := 
    match ( vctx_next_instruction v c) with 
    | Some i => i
    | None => Misc STOP
    end.
(* [?]: removed value specification. *)

Definition vctx_recipient  (v : variable_ctx ) (c : constant_ctx )  : word160 := 
  match ( vctx_next_instruction_default v c) with 
  | Misc SUICIDE => w256_to_address (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v)
  | Misc CALL => w256_to_address (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 1)))) v)
  | Misc CALLCODE =>(cctx_this c)
  | Misc DELEGATECALL =>(cctx_this c)
  | _ =>word160FromNumeral 0
  end.
(* [?]: removed value specification. *)

Definition new_memory_consumption  (i : inst ) (v : variable_ctx )  : Z := 
  match ( i) with 
  | Arith SHA3 => M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 1)))) v)
  | Memory CALLDATACOPY =>
    M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 2)))) v)
  | Memory CODECOPY =>
    M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 2)))) v)
  | Memory EXTCODECOPY =>
    M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 1)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 3)))) v)
  | Memory MLOAD =>
    M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v)(word256FromNumeral 32)
  | Memory MSTORE =>
    M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v)(word256FromNumeral 32)
  | Memory MSTORE8 =>
    M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v)(word256FromNumeral 1)
  | Misc CREATE =>
    M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 1)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 2)))) v)
  | Misc CALL =>
    M (M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 3)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 4)))) v))
      (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 5)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 6)))) v)
  | Misc CALLCODE =>
    M (M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 3)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 4)))) v))
      (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 5)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 6)))) v)
  | Misc DELEGATECALL =>
    M (M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 2)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 3)))) v))
      (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 4)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 5)))) v)
  | Misc RETURN =>
    M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 1)))) v)
  | Log _ => M(vctx_memory_usage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 1)))) v)
  | _ =>(vctx_memory_usage v)
  end.
(* [?]: removed value specification. *)

Definition predict_gas  (i : inst ) (v : variable_ctx ) (c : constant_ctx )  : Z := 
  C(vctx_memory_usage v) (new_memory_consumption i v) (vctx_next_instruction_default v c)
    (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 1)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 2)))) v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 3)))) v)
    (negb (ii(vctx_account_existence v) (vctx_recipient v c))) (ii(vctx_storage v) (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 0)))) v))
    (vctx_stack_default((Zpred (Zpos (P_of_succ_nat 1)))) v)(vctx_gas v) (word256ToNatural(block_number(vctx_block v))).
(* [?]: removed value specification. *)

Definition check_resources  (v : variable_ctx ) (c : constant_ctx ) (s : list (word256 )) (i : inst )  : bool := 
  match ( inst_stack_numbers i) with 
  | (consumed,  produced) =>
    ( int_lteb (Coq.ZArith.BinInt.Zminus (Coq.ZArith.BinInt.Zplus((Zpred (Zpos (P_of_succ_nat (List.length s))))) produced) consumed)((Zpred (Zpos (P_of_succ_nat 1024))))) &&
    ( int_lteb(predict_gas i v c)(vctx_gas v))
  end.
(* [?]: removed value specification. *)

Definition subtract_gas  (consumption : Z ) (orig : instruction_result )  : instruction_result := 
  match ( orig) with 
  | InstructionContinue v =>
    InstructionContinue ({[ v with vctx_gas := Coq.ZArith.BinInt.Zminus(vctx_gas v) consumption  ]})
  | InstructionAnnotationFailure => InstructionAnnotationFailure
  | InstructionToEnvironment act v opt =>
    InstructionToEnvironment act ({[v with vctx_gas := Coq.ZArith.BinInt.Zminus(vctx_gas v) consumption ]}) opt
  end.
(* [?]: removed value specification. *)

Definition signextend  (len : word256 ) (w : word256 )  : word256 := 
  if int_gteb (uint len)((Zpred (Zpos (P_of_succ_nat 31)))) then
    w
  else
    let len : nat  := Coq.Init.Peano.mult( 8) ( Coq.Init.Peano.plus( (word256ToNatural len))( 1)) in
    let mask : word256  := word256Minus (word256Power(word256FromNumeral 2) len)(word256FromNumeral 1) in
    let masked : word256  := word256Land w mask in
    let middle : word256  := word256Power(word256FromNumeral 2) ( Coq.Init.Peano.minus len( 1)) in
    if w256Less masked middle then masked
    else word256Minus (word256Minus masked middle) middle.
(* [?]: removed value specification. *)

Definition instruction_sem  (v : variable_ctx ) (c : constant_ctx ) (inst1 : inst )  : instruction_result := 
  subtract_gas (predict_gas inst1 v c)
  (match ( inst1) with 
  | Stack( PUSH_N lst) => stack_0_1_op v c (word_of_bytes (constant_mark lst))
  | Unknown _ => instruction_failure_result v [ShouldNotHappen]
  | Storage SLOAD => stack_1_1_op v c(vctx_storage v)
  | Storage SSTORE => sstore v c
  | Pc JUMPI => jumpi v c
  | Pc JUMP => jump v c
  | Pc JUMPDEST => stack_0_0_op v c
  | Info CALLDATASIZE => stack_0_1_op v c (datasize v)
  | Stack CALLDATALOAD => stack_1_1_op v c (cut_data v)
  | Info CALLER => stack_0_1_op v c (address_to_w256(vctx_caller v))
  | Arith ADD => stack_2_1_op v c (fun (a : word256 ) (b : word256 ) => word256Add a b)
  | Arith SUB => stack_2_1_op v c (fun (a : word256 ) (b : word256 ) => word256Minus a b)
  | Arith ISZERO => stack_1_1_op v c (fun (a : word256 ) => if classical_boolean_equivalence a(word256FromNumeral 0) then (word256FromNumeral 1) else (word256FromNumeral 0))
  | Misc CALL => call v c
  | Misc RETURN => ret v c
  | Misc STOP => stop v c
  | Dup n => general_dup n v c
  | Stack POP => pop v c
  | Info GASLIMIT => stack_0_1_op v c(block_gaslimit(vctx_block v))
  | Arith inst_GT => stack_2_1_op v c (fun (a : word256 ) (b : word256 ) => if word256UGT a b then (word256FromNumeral 1) else (word256FromNumeral 0))
  | Arith inst_EQ => stack_2_1_op v c (fun (a : word256 ) (b : word256 ) => if classical_boolean_equivalence a b then (word256FromNumeral 1) else (word256FromNumeral 0))
  | Bits inst_AND => stack_2_1_op v c (fun (a : word256 ) (b : word256 ) => word256Land a b)
  | Bits inst_OR => stack_2_1_op v c (fun (a : word256 ) (b : word256 ) => word256Lor a b)
  | Bits inst_XOR => stack_2_1_op v c (fun (a : word256 ) (b : word256 ) => word256Lxor a b)
  | Bits inst_NOT => stack_1_1_op v c (fun (a : word256 ) => word256Lnot a)
  | Bits BYTE =>
      stack_2_1_op v c get_byte
  | Sarith SDIV => stack_2_1_op v c
       (fun (n : word256 ) (divisor : word256 ) => if classical_boolean_equivalence divisor(word256FromNumeral 0) then (word256FromNumeral 0) else
                         let divisor := sintFromW256 divisor in
                         let n := sintFromW256 n in
                         let min_int : Z  := (Coq.ZArith.BinInt.Zminus Z0 ( Coq.ZArith.Zpower.Zpower_nat((Zpred (Zpos (P_of_succ_nat 2))))( 255))) in
                         if Z.eqb n min_int && Z.eqb divisor ((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) then word256FromInteger min_int else
                         if int_ltb divisor((Zpred (Zpos (P_of_succ_nat 0)))) then
                           (if int_ltb n((Zpred (Zpos (P_of_succ_nat 0)))) then
                              word256FromInteger ( Coq.ZArith.Zdiv.Zdiv( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) n) ( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) divisor))
                            else
                              word256FromInteger ( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) ( Coq.ZArith.Zdiv.Zdiv n ( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) divisor)))
                           )
                         else
                           (if int_ltb n((Zpred (Zpos (P_of_succ_nat 0)))) then
                              word256FromInteger ( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) ( Coq.ZArith.Zdiv.Zdiv( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) n) divisor))
                            else
                              word256FromInteger ( Coq.ZArith.Zdiv.Zdiv n divisor))
                           )
  | Sarith SMOD => stack_2_1_op v c
       (fun (n : word256 ) (divisor : word256 ) => if classical_boolean_equivalence divisor(word256FromNumeral 0) then (word256FromNumeral 0) else
                         let divisor := sintFromW256 divisor in
                         let n := sintFromW256 n in
                         if int_ltb divisor((Zpred (Zpos (P_of_succ_nat 0)))) then
                           (if int_ltb n((Zpred (Zpos (P_of_succ_nat 0)))) then
                              word256FromInteger ( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) ( Coq.ZArith.Zdiv.Zmod( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) n) ( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) divisor)))
                            else
                              word256FromInteger ( Coq.ZArith.Zdiv.Zmod n ( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) divisor))
                           )
                         else
                           (if int_ltb n((Zpred (Zpos (P_of_succ_nat 0)))) then
                              word256FromInteger ( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) ( Coq.ZArith.Zdiv.Zmod( Coq.ZArith.BinInt.Zmult((Coq.ZArith.BinInt.Zminus Z0 ((Zpred (Zpos (P_of_succ_nat 1)))))) n) divisor))
                            else
                              word256FromInteger ( Coq.ZArith.Zdiv.Zmod n divisor))
                           )
  | Sarith SGT => stack_2_1_op v c
       (fun (elm0 : word256 ) (elm1 : word256 ) => if w256Greater elm0 elm1 then (word256FromNumeral 1) else (word256FromNumeral 0))
  | Sarith SLT => stack_2_1_op v c
       (fun (elm0 : word256 ) (elm1 : word256 ) => if w256Less elm0 elm1 then (word256FromNumeral 1) else (word256FromNumeral 0))
  | Sarith SIGNEXTEND => stack_2_1_op v c signextend
  | Arith MUL => stack_2_1_op v c
       (fun (a : word256 ) (b : word256 ) => word256Mult a b)
  | Arith DIV => stack_2_1_op v c
       (fun (a : word256 ) (divisor : word256 ) => (if classical_boolean_equivalence divisor(word256FromNumeral 0) then (word256FromNumeral 0) else word256FromInteger ( Coq.ZArith.Zdiv.Zdiv(uint a) (uint divisor))))
  | Arith MOD => stack_2_1_op v c
       (fun (a : word256 ) (divisor : word256 ) => (if classical_boolean_equivalence divisor(word256FromNumeral 0) then (word256FromNumeral 0) else
            word256FromInteger ( Coq.ZArith.Zdiv.Zmod(uint a) (uint divisor))
        ))
  | Arith ADDMOD => stack_3_1_op v c
       (fun (a : word256 ) (b : word256 ) (divisor : word256 ) =>
           (if classical_boolean_equivalence divisor(word256FromNumeral 0) then (word256FromNumeral 0) else word256FromInteger ( Coq.ZArith.Zdiv.Zmod( Coq.ZArith.BinInt.Zplus(uint a) (uint b)) (uint divisor))))
  | Arith MULMOD => stack_3_1_op v c
       (fun (a : word256 ) (b : word256 ) (divisor : word256 ) =>
           (if classical_boolean_equivalence divisor(word256FromNumeral 0) then (word256FromNumeral 0) else word256FromInteger ( Coq.ZArith.Zdiv.Zmod( Coq.ZArith.BinInt.Zmult(uint a) (uint b)) (uint divisor))))
  | Arith EXP => stack_2_1_op v c (fun (a : word256 ) (exponent : word256 ) => word256FromInteger (word_exp (uint a) (word256ToNatural exponent)))
  | Arith inst_LT => stack_2_1_op v c (fun (arg0 : word256 ) (arg1 : word256 ) => if word256UGT arg1 arg0 then (word256FromNumeral 1) else (word256FromNumeral 0))
  | Arith SHA3 => sha3 v c
  | Info ADDRESS => stack_0_1_op v c (address_to_w256(cctx_this c))
  | Info BALANCE => stack_1_1_op v c (fun (addr : word256 ) =>(vctx_balance v) (w256_to_address addr))
  | Info ORIGIN => stack_0_1_op v c (address_to_w256(vctx_origin v))
  | Info CALLVALUE => stack_0_1_op v c(vctx_value_sent v)
  | Info CODESIZE => stack_0_1_op v c (word256FromInteger(program_length(cctx_program c)))
  | Info GASPRICE => stack_0_1_op v c(block_gasprice(vctx_block v))
  | Info EXTCODESIZE => stack_1_1_op v c
       (fun (arg : word256 ) => word256FromInteger(program_length (ii(vctx_ext_program v) (w256_to_address arg))))
  | Info BLOCKHASH => stack_1_1_op v c(block_blockhash(vctx_block v))
  | Info COINBASE => stack_0_1_op v c (address_to_w256(block_coinbase(vctx_block v)))
  | Info TIMESTAMP => stack_0_1_op v c(block_timestamp(vctx_block v))
  | Info NUMBER => stack_0_1_op v c(block_number(vctx_block v))
  | Info DIFFICULTY => stack_0_1_op v c(block_difficulty(vctx_block v))
  | Memory MLOAD => mload v c
  | Memory MSTORE => mstore v c
  | Memory MSTORE8 => mstore8 v c
  | Memory CALLDATACOPY => calldatacopy v c
  | Memory CODECOPY => codecopy v c
  | Memory EXTCODECOPY => extcodecopy v c
  | Pc PC => pc v c
  | Log LOG0 => log( 0) v c
  | Log LOG1 => log( 1) v c
  | Log LOG2 => log( 2) v c
  | Log LOG3 => log( 3) v c
  | Log LOG4 => log( 4) v c
  | Swap n => swap (word4ToNat n) v c
  | Misc CREATE => create v c
  | Misc CALLCODE => callcode v c
  | Misc SUICIDE => suicide v c
  | Misc DELEGATECALL => delegatecall v c
  | Info GAS => stack_0_1_op v c ( word256Minus(gas v)(word256FromNumeral 2))
  | Memory MSIZE => stack_0_1_op v c ( word256Mult(word256FromNumeral 32) (word256FromInteger(vctx_memory_usage v)))
  end).
(* [?]: removed value specification. *)

Definition check_annotations  (v : variable_ctx ) (c : constant_ctx )  : bool := 
  let annots : list  annotation  :=(program_annotation(cctx_program c))(vctx_pc v) in
  List.forallb (fun (annot : aenv  -> bool ) => annot (build_aenv v c)) annots.
(* [?]: removed value specification. *)

Definition next_state  (stopper : instruction_result  -> unit ) (c : constant_ctx ) (pr : instruction_result )  : instruction_result := 
  match ( pr) with 
  | InstructionToEnvironment _ _ _ => 
  match ( stopper pr) with tt => pr end
  | InstructionAnnotationFailure => 
  match ( stopper pr) with tt => pr end
  | InstructionContinue v =>
     if negb (check_annotations v c) then InstructionAnnotationFailure else
     match ( vctx_next_instruction v c) with 
      | None => InstructionToEnvironment (ContractFail [ShouldNotHappen]) v None
      | Some i =>
        if check_resources v c(vctx_stack v) i then
          instruction_sem v c i
        else
          InstructionToEnvironment (ContractFail
              (match ( inst_stack_numbers i) with 
               | (consumed,  produced) =>
                 
                  (@ List.app _)(if ( int_lteb (Coq.ZArith.BinInt.Zminus (Coq.ZArith.BinInt.Zplus((Zpred (Zpos (P_of_succ_nat (List.length(vctx_stack v)))))) produced) consumed)((Zpred (Zpos (P_of_succ_nat 1024))))) then [] else [TooLongStack]) (if int_lteb (predict_gas i v c)(vctx_gas v) then [] else [OutOfGas])
               end
              ))
              v None
     end
  end.
(* [?]: removed value specification. *)

Program Fixpoint program_sem  (stopper : instruction_result  -> unit ) (c : constant_ctx ) (fuel : nat ) (pr : instruction_result )  : instruction_result := 
match ( fuel) with 
 | 0 => pr
 | S (fuel_pred) => program_sem stopper c fuel_pred (next_state stopper c pr)
end.

(* subsection {* Account's State *} *)

(* In the bigger picture, a contract invocation changes accounts' states. *)
(* An account has a storage, a piece of code and a balance. *)
(* Since I am interested in account states in the middle of a transaction, I also need to *)
(* keep track of the ongoing executions of a single account.  Also I need to keep track of *)
(* a flag indicating if the account has already marked for erasure. *)

Record account_state : Type := {
  account_address : address ;
  account_storage : storage ;
  account_code : program ;
  account_balance : w256 ;
  account_ongoing_calls : list  ((variable_ctx  * Z  * Z ) % type);
    (* the variable environments that are executing on this account, but waiting for calls to finish *)
  account_killed : bool 
    (* the boolean that indicates the account has executed SUICIDE in this transaction. *)
  (* The flag causes a destruction of the contract at the end of a transaction. *)
}.
Notation "{[ r 'with' 'account_address' := e ]}" := ({| account_address := e; account_storage := account_storage r; account_code := account_code r; account_balance := account_balance r; account_ongoing_calls := account_ongoing_calls r; account_killed := account_killed r |}).
Notation "{[ r 'with' 'account_storage' := e ]}" := ({| account_storage := e; account_address := account_address r; account_code := account_code r; account_balance := account_balance r; account_ongoing_calls := account_ongoing_calls r; account_killed := account_killed r |}).
Notation "{[ r 'with' 'account_code' := e ]}" := ({| account_code := e; account_address := account_address r; account_storage := account_storage r; account_balance := account_balance r; account_ongoing_calls := account_ongoing_calls r; account_killed := account_killed r |}).
Notation "{[ r 'with' 'account_balance' := e ]}" := ({| account_balance := e; account_address := account_address r; account_storage := account_storage r; account_code := account_code r; account_ongoing_calls := account_ongoing_calls r; account_killed := account_killed r |}).
Notation "{[ r 'with' 'account_ongoing_calls' := e ]}" := ({| account_ongoing_calls := e; account_address := account_address r; account_storage := account_storage r; account_code := account_code r; account_balance := account_balance r; account_killed := account_killed r |}).
Notation "{[ r 'with' 'account_killed' := e ]}" := ({| account_killed := e; account_address := account_address r; account_storage := account_storage r; account_code := account_code r; account_balance := account_balance r; account_ongoing_calls := account_ongoing_calls r |}).
Definition account_state_default: account_state  := {| account_address := address_default; account_storage := storage_default; account_code := program_default; account_balance := w256_default; account_ongoing_calls := DAEMON; account_killed := bool_default |}.
(* [?]: removed value specification. *)

Definition build_cctx  (a : account_state )  : constant_ctx := 
  {|cctx_program :=(account_code a);cctx_this :=(account_address a) |}.
(* [?]: removed value specification. *)

Definition is_call_like  (i : option (inst ) )  : bool :=  ( (maybeEqualBy classical_boolean_equivalence i (Some (Misc CALL))) || ((maybeEqualBy classical_boolean_equivalence i (Some (Misc DELEGATECALL)))
                 || ((maybeEqualBy classical_boolean_equivalence i (Some (Misc CALLCODE))) || (maybeEqualBy classical_boolean_equivalence i (Some (Misc CREATE)))))).
(* [?]: removed value specification. *)

Definition build_vctx_failed  (a : account_state )  : option (variable_ctx ) :=  match ((account_ongoing_calls a)) with 
 | [] => None
 | (recovered, _, _) :: _ =>
      if is_call_like ((program_content(ii(account_code a))) ( Coq.ZArith.BinInt.Zminus(ii(vctx_pc recovered))((Zpred (Zpos (P_of_succ_nat 1)))))) then
      Some ({[ recovered with vctx_stack :=word256FromNumeral 0 ::(vctx_stack recovered)  ]}) (* 0 is pushed, indicating failure*)
      else None
end.
(* [?]: removed value specification. *)

Definition account_state_pop_ongoing_call  (orig : account_state )  : account_state :=  match ((account_ongoing_calls orig)) with 
 | _ :: tl => {[ orig with account_ongoing_calls := tl  ]}
 | _ => {[ orig with account_ongoing_calls := []  ]}
end.
(* [?]: removed value specification. *)

Definition empty_account  (addr : word160 )  : account_state := 
 {|account_address := addr;account_storage := empty_storage;account_code := empty_program;account_balance :=(word256FromNumeral 0);account_ongoing_calls := [];account_killed := false
 |}.
(* [?]: removed value specification. *)

Definition update_account_state  (prev : account_state ) (act : contract_action ) (v : variable_ctx ) (v_opt : option ((Z *Z ) % type) )  : account_state := 
   let st := (match ( act) with  ContractFail _ =>(vctx_storage_at_call v) | _ =>(vctx_storage v) end) in
   let bal := (match ( act) with  ContractFail _ =>(vctx_balance_at_call v) | _ =>(vctx_balance v) end) in {[ {[ {[
   {[ prev with account_killed :=
       (match ( act) with  ContractSuicide => true
                  | _ =>(account_killed prev) end)
     ]} with account_ongoing_calls :=
                        (match ( v_opt) with  None =>(account_ongoing_calls prev)
                                     | Some (i,  s) => (v, i, s) ::(account_ongoing_calls prev) end)  ]} with account_balance := (match ( act) with  ContractFail _ =>(account_balance prev)
                                   |  _ => bal(account_address prev) end)  ]} with account_storage := st  ]}.

Definition contract_behavior : Type := ( contract_action  * (account_state  ->  bool )) % type.
Definition contract_behavior_default: contract_behavior  := (contract_action_default, (fun (x107 : account_state ) => bool_default)).

Record response_to_environment : Type := {
  when_called : call_env  ->  contract_behavior ;
  when_returned : return_result  ->  contract_behavior ;
  when_failed : contract_behavior 
}.
Notation "{[ r 'with' 'when_called' := e ]}" := ({| when_called := e; when_returned := when_returned r; when_failed := when_failed r |}).
Notation "{[ r 'with' 'when_returned' := e ]}" := ({| when_returned := e; when_called := when_called r; when_failed := when_failed r |}).
Notation "{[ r 'with' 'when_failed' := e ]}" := ({| when_failed := e; when_called := when_called r; when_returned := when_returned r |}).
Definition response_to_environment_default: response_to_environment  := {| when_called := (fun (x105 :  call_env ) => contract_behavior_default); when_returned := (fun (x106 :  return_result ) => contract_behavior_default); when_failed := contract_behavior_default |}.
(* [?]: removed value specification. *)

Definition empty_memory   : word256  -> word8 :=  (fun  _ : word256  =>word8FromNumeral 0).
Inductive build_vctx_called: (account_state) -> (call_env) -> (variable_ctx) -> Prop :=
  | vctx_called: forall bal a env origin ext block0 gas0 existence, ( nat_gteb    
(word256ToNatural(block_number block0))(Coq.Init.Peano.mult( 2463)( 1000)):Prop) -> ( classical_boolean_equivalence    
( (* only the newest version of EVM matters *)bal(account_address a))(account_balance a):Prop) -> build_vctx_called   a  env 
 {|vctx_stack := [];vctx_memory := empty_memory;vctx_memory_usage :=((Zpred (Zpos (P_of_succ_nat 0))));vctx_storage :=(account_storage a);vctx_pc :=((Zpred (Zpos (P_of_succ_nat 0))));vctx_balance := (fun  (addr:address ) =>
                         if classical_boolean_equivalence addr(account_address a)
                           then word256Add (bal(account_address a))(callenv_value env) else bal addr);vctx_caller :=(callenv_caller env);vctx_value_sent :=(callenv_value env);vctx_data_sent :=(callenv_data env);vctx_storage_at_call :=(account_storage a);vctx_balance_at_call := bal;vctx_origin := origin;vctx_ext_program := ext;vctx_block := block0;vctx_gas := gas0;vctx_account_existence := existence;vctx_touched_storage_index := [];vctx_logs := []
   |}.
Inductive build_vctx_returned: (account_state) -> (return_result) -> (variable_ctx) -> Prop :=
  | vctx_returned: forall a_code v_pc new_bal a_bal a_addr a_storage v_stack v_memory v_memory_usage v_storage v_balance v_caller v_value v_data v_init_storage v_init_balance v_origin v_ext_program v_ext_program' v_block v_gas v_gas' mem_start mem_size r rest whichever v_ex v_ex' v_touched v_logs, (is_call_like (ii(program_content a_code) ( Coq.ZArith.BinInt.Zminus v_pc((Zpred (Zpos (P_of_succ_nat 1)))))):Prop) -> (word256UGE new_bal a_bal:Prop) -> build_vctx_returned  

     (* here is the first argument *)
     {|account_address := a_addr (* all elements are spelled out for performance *)
     ;account_storage := a_storage
     ;account_code := a_code
     ;account_balance := a_bal
     ;account_ongoing_calls :=
         (({|vctx_stack := v_stack
         ;vctx_memory := v_memory
         ;vctx_memory_usage := v_memory_usage
         ;vctx_storage := v_storage
         ;vctx_pc := v_pc
         ;vctx_balance := v_balance
         ;vctx_caller := v_caller
         ;vctx_value_sent := v_value
         ;vctx_data_sent := v_data
         ;vctx_storage_at_call := v_init_storage
         ;vctx_balance_at_call := v_init_balance
         ;vctx_origin := v_origin
         ;vctx_ext_program := v_ext_program
         ;vctx_block := v_block
         ;vctx_gas := v_gas
         ;vctx_account_existence := v_ex
         ;vctx_touched_storage_index := v_touched
         ;vctx_logs := v_logs
         |}, mem_start, mem_size) :: rest)
     ;account_killed := whichever
     |} 

     (* here is the second argument *)
     r 

     (* here is the third argument *)
     ({|vctx_stack :=(word256FromNumeral 1 :: v_stack) (* 1 is pushed, indicating a return *)
       ;vctx_memory :=         
(put_return_values v_memory(return_data r) mem_start mem_size)
       ;vctx_memory_usage := v_memory_usage
       ;vctx_storage := a_storage
       ;vctx_pc := v_pc
       ;vctx_balance := (update_balance a_addr
                            (fun  _ : word256  => new_bal)(return_balance r))
       ;vctx_caller := v_caller
       ;vctx_value_sent := v_value
       ;vctx_data_sent := v_data
       ;vctx_storage_at_call := v_init_storage
       ;vctx_balance_at_call := v_init_balance
       ;vctx_origin := v_origin
       ;vctx_ext_program := v_ext_program'
       ;vctx_block := v_block
       ;vctx_gas := v_gas' (* safe approximation.  saving proof space *)
       ;vctx_account_existence := v_ex'
       ;vctx_touched_storage_index := v_touched
       ;vctx_logs := v_logs
      |}).
