open import Pervasives
open import Word
open import Word256
open import Word160
open import Word8
open import Evm

val respond_to_call_correctly : (call_env -> contract_behavior) -> account_state -> bool
let respond_to_call_correctly c a =
  (forall call_env initial_vctx resulting_action final_state_pred.
     build_vctx_called a call_env initial_vctx -->
         (* The specification says the execution should result in these *)
         c call_env = (resulting_action, final_state_pred) -->
         (forall steps. (* and for any number of steps *)
           ( let r = program_sem initial_vctx (build_cctx a) a.account_code.program_length steps in
             (* either more steps are necessary, or *)
             r = ProgramStepRunOut ||
             (* the result matches the specification *)
             (exists pushed_vctx st bal.
              r = ProgramToEnvironment resulting_action st bal pushed_vctx &&
              final_state_pred
                (update_account_state a resulting_action st bal pushed_vctx))
           )))

val respond_to_return_correctly : (return_result -> contract_behavior) -> account_state -> bool
let respond_to_return_correctly r a =
   (forall rr initial_vctx final_state_pred resulting_action.
       build_vctx_returned a rr initial_vctx -->
       r rr = (resulting_action, final_state_pred) -->
       (forall steps.
          (let r = program_sem initial_vctx (build_cctx a) a.account_code.program_length steps in
           r = ProgramStepRunOut ||
           (exists pushed_vctx st bal.
            r = ProgramToEnvironment resulting_action st bal pushed_vctx &&
            final_state_pred
              (update_account_state (account_state_pop_ongoing_call a) resulting_action st bal pushed_vctx))
          )))

val respond_to_fail_correctly : contract_behavior -> account_state -> bool
let respond_to_fail_correctly f a =
   (forall initial_vctx final_state_pred resulting_action.
      Just initial_vctx = build_vctx_failed a -->
      f = (resulting_action, final_state_pred) -->
      (forall steps.
        ( let r = program_sem initial_vctx (build_cctx a) a.account_code.program_length steps in
          r = ProgramStepRunOut ||
          (exists pushed_vctx st bal.
             r = ProgramToEnvironment resulting_action st bal pushed_vctx &&
             final_state_pred (update_account_state (account_state_pop_ongoing_call a) resulting_action st bal pushed_vctx)))))

indreln [account_state_responds_to_environment : (account_state -> bool) -> response_to_environment -> bool]
AccountStep: forall precond c r f.
  (forall a. precond a --> respond_to_call_correctly c a) &&
   (forall a. precond a --> respond_to_return_correctly r a) &&
   (forall a. precond a --> respond_to_fail_correctly f a) ==>
   account_state_responds_to_environment precond <| when_called = c; when_returned = r; when_failed = f |>
